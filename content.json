{"meta":{"title":"RuoShuiSanQian","subtitle":null,"description":null,"author":"HickSalmon","url":"https://hick-salmon.github.io/Hick-Salmon","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-16T03:08:20.808Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"/404.html","permalink":"https://hick-salmon.github.io/Hick-Salmon//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-07-19T08:47:28.194Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"books/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-16T03:08:20.833Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-16T03:08:20.848Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-19T08:47:42.585Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"repository/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-16T03:08:20.837Z","updated":"2019-03-28T01:36:53.000Z","comments":true,"path":"links/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-13T07:36:06.517Z","updated":"2019-07-13T07:36:06.517Z","comments":false,"path":"about/index.html","permalink":"https://hick-salmon.github.io/Hick-Salmon/about/index.html","excerpt":"","text":"HickSalmon，一个昵称。Hick 意为乡巴佬，Salmon 是表示大马哈鱼的意思。 # 曾梦想仗剑走天涯，后因 bug 太多没去。 &nbsp;&nbsp;&nbsp;&nbsp;1.2019年毕业于湖北民族大学； &nbsp;&nbsp;&nbsp;&nbsp;2.2019.7.1-至今就职于恩施师达电子科技有限公司，担任 Java 开发工程师。"}],"posts":[{"title":"20.FlutterExpansionTile实现开关闭合","slug":"20.Flutter--ExpansionTile实现开关闭合","date":"2019-07-18T03:50:01.000Z","updated":"2019-07-19T08:38:20.283Z","comments":true,"path":"2019/07/18/20.Flutter--ExpansionTile实现开关闭合/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/18/20.Flutter--ExpansionTile实现开关闭合/","excerpt":"","text":"Flutter ExpansionTile实现开关闭合 main.dart 文件 123456789101112131415import 'package:flutter/material.dart';import 'package:demo08/expantion_tile.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: '展开闭合', theme: ThemeData.light(), home: ExpansionTileDemo(), ); &#125;&#125; expansion_tile.dart 代码，模拟后台传过来的数据 123456789101112131415161718192021222324252627import 'package:flutter/material.dart';class ExpansionTileDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('ExpansionTile Test'),), body: Center( //使用展开闭合的组件 ExpansionTile child: ExpansionTile( title: Text('测试开关闭合'), leading: Icon(Icons.ac_unit), backgroundColor: Colors.amber, children: &lt;Widget&gt;[ ListTile( title: Text('开了'), subtitle: Text('子标题咱也可以显示'), ) ], //设置是否展开的，true 展开，默认是 false // initiallyExpanded: true, ), ), ); &#125;&#125; 效果 2019/7/18:成熟不是为了走向复杂，而是为了抵达天真。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"19.FlutterWrap流式布局","slug":"19.FlutterWrap流式布局","date":"2019-07-17T03:50:01.000Z","updated":"2019-07-19T08:37:25.297Z","comments":true,"path":"2019/07/17/19.FlutterWrap流式布局/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/17/19.FlutterWrap流式布局/","excerpt":"","text":"Flutter Wrap流式布局 main.dart 文件 123456789101112131415import 'package:flutter/material.dart';import 'package:demo07/wrap_app.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Wrap 流式布局', theme: ThemeData.dark(), home: WrapApp(), ); &#125;&#125; wrao_app.dart 代码，模拟后台传过来的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import 'package:flutter/material.dart';class WrapApp extends StatefulWidget &#123; @override _WrapAppState createState() =&gt; _WrapAppState();&#125;class _WrapAppState extends State&lt;WrapApp&gt; &#123; List&lt;Widget&gt; list; @override void initState() &#123; list = List&lt;Widget&gt;()..add(_addButton()); super.initState(); &#125; @override Widget build(BuildContext context) &#123; //这里是一个新的知识点，我们可以通过这种媒体查询来获取手机狂宽高 final width = MediaQuery.of(context).size.width; final height = MediaQuery.of(context).size.height; return Scaffold( appBar: AppBar(title: Text('Wrap 流式布局'),), body: Center( child: Opacity( opacity: 0.8, child: Container( width: width, height: height/2, color: Colors.grey, //这里就是今天的重头戏，需要使用流式布局 child: Wrap( children: list, spacing: 26.0, ), ), ), ), ); &#125; Widget _addButton()&#123; return GestureDetector( onTap: ()&#123; if(list.length &lt; 9)&#123; //这里是个坑，因为我们在上面创建的是 State 的， //所以我们这里需要实时的进行改变，但是 Flutter 并不支持双向绑定， //所以我们在添加时，必须使用 setState()&#123;&#125; setState(() &#123; list.insert(list.length - 1, _buildPhoto()); &#125;); &#125; &#125;, child: Padding( padding: EdgeInsets.all(8.0), child: Container( width: 70.0, height: 70.0, color: Colors.black54, child: Icon( Icons.add ), ), ), ); &#125; Widget _buildPhoto()&#123; return Padding( padding: const EdgeInsets.all(8.0), child: Container( width: 70.0, height: 70.0, color: Colors.amber, child: Text('照片'), ), ); &#125;&#125; 效果 2019/7/17:心中有丘壑，眉目纵山河。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"17.Flutter页面状态保持","slug":"17.Flutter页面状态保持","date":"2019-07-16T03:50:01.000Z","updated":"2019-07-19T08:36:33.009Z","comments":true,"path":"2019/07/16/17.Flutter页面状态保持/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/16/17.Flutter页面状态保持/","excerpt":"","text":"Flutter 页面状态保持 main.dart 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import 'package:flutter/material.dart';import 'package:demo05/keep_alive.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.lightBlue, ), home: KeepAliveDemo(), ); &#125;&#125;class KeepAliveDemo extends StatefulWidget &#123; @override _KeepAliveDemoState createState() =&gt; _KeepAliveDemoState();&#125;//这里引入 with 关键字， dart 没有多继承，使用 混入 这个概念class _KeepAliveDemoState extends State&lt;KeepAliveDemo&gt; with SingleTickerProviderStateMixin&#123; TabController _controller; @override void initState() &#123; _controller = TabController(length: 3, vsync: this); super.initState(); &#125; @override void dispose() &#123; _controller.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Keep Alive Demo'), bottom: TabBar( controller: _controller, tabs: &lt;Widget&gt;[ Tab(icon: Icon(Icons.directions_bike),), Tab(icon: Icon(Icons.directions_transit),), Tab(icon: Icon(Icons.directions_car),) ], ), ), //这里与上面的 TarBar保持一致 body: TabBarView( controller: _controller, children: &lt;Widget&gt;[ MyHomePage(), MyHomePage(), MyHomePage() ], ), ); &#125;&#125; keep_alive.dart 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'package:flutter/material.dart';class MyHomePage extends StatefulWidget &#123; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;//混入 AutomaticKeepAliveClientMixin 实现页面状态不更改class _MyHomePageState extends State&lt;MyHomePage&gt; with AutomaticKeepAliveClientMixin &#123; //计数器 int _count = 0; //重写方法，否则报错 @override bool get wantKeepAlive =&gt; true; //定义一个增加计数器的方法 void incrementCount()&#123; setState(() &#123; _count++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('点一次增加一个数字'), Text('$_count', style: Theme.of(context).textTheme.display1, ) ], ), ), floatingActionButton: FloatingActionButton( onPressed: incrementCount, tooltip: '增加', child: Icon(Icons.add), ), ); &#125;&#125; 效果","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"18.Flutter搜索条","slug":"18.Flutter搜索条","date":"2019-07-16T03:50:01.000Z","updated":"2019-07-19T08:37:00.194Z","comments":true,"path":"2019/07/16/18.Flutter搜索条/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/16/18.Flutter搜索条/","excerpt":"","text":"Flutter 搜索条 main.dart 文件 123456789101112131415import 'package:flutter/material.dart';import 'package:demo06/search_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData.light(), home: SearchBar(), ); &#125;&#125; asset.dart 代码，模拟后台传过来的数据 12345678910111213141516const searchList = [ \"麻子哥111111111\", \"骚练22222222\", \"亦肥333333333\", \"旺仔44444444\", \"启航55555555\", \"傲翊66666666\", \"宋吉吉77777777\", \"太军8888888888\"];const recentSuggest = [ \"骚棒1\", \"骚棒2\", \"骚棒3\"]; search_bar.dart代码，主要重写 SearchDelegate 的四个方法。需要留意他们的参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import 'package:flutter/material.dart';import 'package:demo06/asset.dart';class SearchBar extends StatefulWidget &#123; @override _SearchBarState createState() =&gt; _SearchBarState();&#125;class _SearchBarState extends State&lt;SearchBar&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('SearchBar'), //添加了一个搜索框 actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: ()&#123; showSearch(context: context, delegate: searchBarDelegate()); &#125;, ) ], ), ); &#125;&#125;class searchBarDelegate extends SearchDelegate&lt;String&gt; &#123; //搜索右边的 清除小× @override List&lt;Widget&gt; buildActions(BuildContext context) &#123; return [ IconButton( icon: Icon(Icons.clear), onPressed: () =&gt; query = \"\", ) ]; &#125; //搜索处的返回按钮 @override Widget buildLeading(BuildContext context) &#123; return IconButton( icon: AnimatedIcon( icon: AnimatedIcons.menu_arrow, progress: transitionAnimation, ), onPressed: () =&gt; close(context,null), ); &#125; @override Widget buildResults(BuildContext context) &#123; return Container( width: 100.0, height: 100.0, child: Center( child: Card( color: Colors.redAccent, child: Text(query), ), ), ); &#125; @override Widget buildSuggestions(BuildContext context) &#123; final suggestionList = query.isEmpty ? recentSuggest : searchList.where((input) =&gt; input.startsWith(query)).toList(); return ListView.builder( itemCount: suggestionList.length, itemBuilder: (context,index) =&gt; ListTile( title: RichText( text: TextSpan( text: suggestionList[index].substring(0,query.length), style: TextStyle( color: Colors.black,fontWeight: FontWeight.bold, ), children: [ TextSpan( text: suggestionList[index].substring(query.length), style: TextStyle( color: Colors.grey, ) ), ] ), ), ), ); &#125;&#125; 效果","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"突然内心的挣扎","slug":"突然内心的挣扎","date":"2019-07-16T03:50:01.000Z","updated":"2019-07-19T08:44:42.440Z","comments":true,"path":"2019/07/16/突然内心的挣扎/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/16/突然内心的挣扎/","excerpt":"","text":"突然内心的挣扎 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知是什么时候养成了这种坏习惯。静不下心，懒惰。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天这种感觉又来了，本来准备回家继续好好学习 Flutter 的，可是突然一阵内心的挣扎，让我关掉了学习视频，可是我内心还是不希望这种感觉长久持续的。也正是因此，也许才让我写下这篇随记，好好的思考一下吧。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;究竟是什么让我过段时间就会这样子呢？首先脑袋里闪过的一个想法是每个人都这样吗？但是似乎没有人能回答我的问题，那也就作罢了。只能自己想想是什么了。可能是因为从小到大没有做过一件完整的事吧！每一次的半途而废，或者每一次的失败，让我积累了这种容易受挫的心态，面对新的挑战和困难就会畏缩放弃。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那好像是小学四年级，家里请了锯木料的工人，锯了好多木头，锯末撒了一地，很厚很厚的一层，农村没谁会管这些锯末，自然也没有谁会去收拾干净。正好那时的我痴迷武侠电视剧，不过那时对里面的情情爱爱不懂，只是好奇他们的武功，此念一出，内心也是极其兴奋的，也便开始了各种馊主意开始学武功。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先就是练习翻跟斗，而那片锯末正好成就了我的想法，我开始一步步尝试着用双手支撑着翻，刚开始还是挺费劲，每次翻过去就躺地上了，可是好的是有锯末垫在地上，加之是有双手支撑。怎么摔也不疼，就这样一个人的不断尝试，这片空地自然也成了我每天放学之后的习武之地。经历了差不多一个星期的样子，突然间我可以翻起来了。那时候很兴奋，但是不敢给爸妈讲，因为很可能挨骂甚至是挨打。只能在学校，趁老师不在的时候，给同学们展示一波我的神级操作。可是好景不长，尝到了这个甜头，自然想向更高的层级进阶，一个大胆的想法在我脑中萌动——练习空翻。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说做就做，放学之后，悄悄的就跑到我的练功场所，为了让自己练习更有安全保障，还偷偷抱了一些玉米壳垫起来，万事具备，只差练习，我深呼吸一口气，猛地一个空翻，结果背先落地，那滋味……，现在想想都疼，就这一次，我放弃了。至今我也没学会。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我能记起来的，好像就是从那一次我学会了自暴自弃。每当后面有什么我不想做的，或者难做的，我就会内心产生退缩。到后面的高考，恋爱，甚至是现在自己的专业。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是回过头来想想，这也不算失败，对于最初想要空翻是失败的，但是学会了用手翻也算是一种成功。可是自己刚刚为什么说是失败呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这可能是一种人心不足的表现吧！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最开始我想反思的是什么来着？忘了……我不知道为什么突然自己会有这些想法，可能累了，也可能就是真的像自己所说的这样子。但是总归是不好的，希望自己能够早点好起来。 2019/7/16： 明天会不会更好？","categories":[{"name":"心情","slug":"心情","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/心情/"}]},{"title":"14.Flutter过度动画1","slug":"14.Flutter过度动画1","date":"2019-07-15T03:50:01.000Z","updated":"2019-07-19T08:34:58.847Z","comments":true,"path":"2019/07/15/14.Flutter过度动画1/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/15/14.Flutter过度动画1/","excerpt":"","text":"Flutter Flutter 过度动画1 main.dart 文件 123456789101112131415161718import 'package:flutter/material.dart';import 'package:demo3/FirstPage.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', //自定义主题样本 theme: ThemeData( primaryColor: Colors.white, ), home: FirstPage(), ); &#125;&#125; first_page.dart 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import 'package:flutter/material.dart';import 'package:demo3/custom_route.dart';class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( //设置背景颜色 backgroundColor: Colors.green, appBar: AppBar( leading: Container(), //deepOrange backgroundColor: Colors.blue, title: Text( 'FirstPage', style: TextStyle( color: Colors.white, fontSize: 30.0 ), ), //设置 appBar 与 body 之间的高度，当设置为 0 的时候 appBar 会与 body 完全融合,当你使用不同颜色的时候这个值就感觉没什么影响了 elevation: 4.0, ), body: Center( child: MaterialButton( child: Icon( Icons.navigate_next, color:Colors.deepPurple, size:64.0, ), onPressed: ()&#123; Navigator.of(context).push(CustomRoute(SecondPage())); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( //设置背景颜色 backgroundColor: Colors.deepPurple, appBar: AppBar( backgroundColor: Colors.deepOrange, leading: Container(), title: Text( 'SecondPage', style: TextStyle( fontSize: 30.0, color: Colors.white ), ), //设置 appBar 与 body 之间的高度，当设置为 0 的时候 appBar 会与 body 完全融合,当你使用不同颜色的时候这个值就感觉没什么影响了 elevation: 4.0, ), body: Center( child: MaterialButton( child: Icon( Icons.navigate_before, color:Colors.greenAccent, size:64.0, ), onPressed: ()&#123; Navigator.of(context).pop(); &#125;, ), ), ); &#125;&#125; custom_route.dart 代码 1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';class CustomRoute extends PageRouteBuilder&#123; final Widget widget; CustomRoute(this.widget):super( //设置过渡时间 transitionDuration: Duration(seconds: 1), pageBuilder:( BuildContext context, Animation&lt;double&gt; animate1, Animation&lt;double&gt; animate2, )&#123; return widget; &#125;, //重写transitionBuilder transitionsBuilder:( BuildContext context, Animation&lt;double&gt; animation1, Animation&lt;double&gt; animation2, Widget child )&#123; return FadeTransition( //过度的透明效果 opacity: Tween(begin: 0.0,end: 1.0) .animate(CurvedAnimation( parent:animation1, //设置动画曲线 curve:Curves.fastOutSlowIn ) ), child: child, ); &#125; );&#125; 效果展示","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"15.Flutter过度动画2","slug":"15.Flutter过度动画2","date":"2019-07-15T03:50:01.000Z","updated":"2019-07-19T08:35:21.040Z","comments":true,"path":"2019/07/15/15.Flutter过度动画2/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/15/15.Flutter过度动画2/","excerpt":"","text":"Flutter 过度动画2 main.dart 文件 123456789101112131415161718import 'package:flutter/material.dart';import 'package:demo3/FirstPage.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', //自定义主题样本 theme: ThemeData( primaryColor: Colors.white, ), home: FirstPage(), ); &#125;&#125; first_page.dart 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import 'package:flutter/material.dart';import 'package:demo3/custom_route.dart';class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( //设置背景颜色 backgroundColor: Colors.green, appBar: AppBar( leading: Container(), //deepOrange backgroundColor: Colors.blue, title: Text( 'FirstPage', style: TextStyle( color: Colors.white, fontSize: 30.0 ), ), //设置 appBar 与 body 之间的高度，当设置为 0 的时候 appBar 会与 body 完全融合,当你使用不同颜色的时候这个值就感觉没什么影响了 elevation: 4.0, ), body: Center( child: MaterialButton( child: Icon( Icons.navigate_next, color:Colors.deepPurple, size:64.0, ), onPressed: ()&#123; Navigator.of(context).push(CustomRoute(SecondPage())); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( //设置背景颜色 backgroundColor: Colors.deepPurple, appBar: AppBar( backgroundColor: Colors.deepOrange, leading: Container(), title: Text( 'SecondPage', style: TextStyle( fontSize: 30.0, color: Colors.white ), ), //设置 appBar 与 body 之间的高度，当设置为 0 的时候 appBar 会与 body 完全融合,当你使用不同颜色的时候这个值就感觉没什么影响了 elevation: 4.0, ), body: Center( child: MaterialButton( child: Icon( Icons.navigate_before, color:Colors.greenAccent, size:64.0, ), onPressed: ()&#123; Navigator.of(context).pop(); &#125;, ), ), ); &#125;&#125; custom_route.dart 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import 'package:flutter/material.dart';class CustomRoute extends PageRouteBuilder&#123; final Widget widget; CustomRoute(this.widget):super( //设置过渡时间 transitionDuration: Duration(seconds: 1), pageBuilder:( BuildContext context, Animation&lt;double&gt; animate1, Animation&lt;double&gt; animate2, )&#123; return widget; &#125;, //重写transitionBuilder transitionsBuilder:( BuildContext context, Animation&lt;double&gt; animation1, Animation&lt;double&gt; animation2, Widget child )&#123; //渐隐渐现的过渡动画效果 // return FadeTransition( // //过度的透明效果 // opacity: Tween(begin: 0.0,end: 1.0) // .animate(CurvedAnimation( // parent:animation1, // //设置动画曲线 // curve:Curves.fastOutSlowIn // ) // ), // child: child, // ); //缩放动画 // return ScaleTransition( // scale: Tween(begin: 0.0,end: 1.0).animate(CurvedAnimation( // parent: animation1, // curve: Curves.fastOutSlowIn // )), // child: child, // ); //缩放加旋转动画 // return RotationTransition( // turns: Tween(begin: 0.0,end: 1.0).animate(CurvedAnimation( // parent:animation1, // curve:Curves.fastOutSlowIn // )), // child: ScaleTransition( // scale: Tween(begin: 0.0,end: 1.0).animate(CurvedAnimation( // parent:animation1, // curve:Curves.fastOutSlowIn // )), // child: child, // ), // ); //左右滑动效果 return SlideTransition( //这里和前面不一样，可以理解成 屏幕归一化，左上角是(0.0,0.0),右下角是(1.0,1.0) position: Tween&lt;Offset&gt;( begin: Offset(1.0,0.0), end: Offset(0.0, 0.0) ).animate(CurvedAnimation( parent:animation1, curve:Curves.fastOutSlowIn )), child: child, ); &#125; );&#125; 旋转缩放效果展示 左右滑动效果展示","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"16.Flutter毛玻璃效果","slug":"16.Flutter毛玻璃效果","date":"2019-07-15T03:50:01.000Z","updated":"2019-07-19T08:36:02.949Z","comments":true,"path":"2019/07/15/16.Flutter毛玻璃效果/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/15/16.Flutter毛玻璃效果/","excerpt":"","text":"Flutter 毛玻璃效果 main.dart 文件 12345678910111213141516171819import 'package:flutter/material.dart';import 'frosted_glass.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo Of XTJ', theme: ThemeData( primarySwatch:Colors.blue, ), home: Scaffold( body: FrostedGlassDemo(), ), ); &#125;&#125; frosted_glass.dart 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';import 'dart:ui';class FrostedGlassDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('毛玻璃效果'),), //层叠组件 body: Stack( //放置图片，毛玻璃效果，以及毛玻璃上的文字 children: &lt;Widget&gt;[ //约束性盒子部件，添加额外的约束在 child 上面 ConstrainedBox( constraints: const BoxConstraints.expand(), child: Image.asset('images/maoboli.jpg'), ), Center( child: ClipRect( //背景过滤器 child: BackdropFilter( //图片过滤器 filter: ImageFilter.blur(sigmaX: 5.0,sigmaY: 5.0), child: Opacity( opacity: 0.5, child: Container( width: 500.0, height: 700.0, decoration: BoxDecoration(color: Colors.grey.shade200), child: Center( child: Text( '夏日的小清新', style: Theme.of(context).textTheme.display1, ), ), ), ), ), ), ), ], ), ); &#125;&#125; 未加毛玻璃效果 毛玻璃效果","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"13.Flutter底部导航栏动态生成及浮动按钮与导航栏的融合","slug":"13.Flutter底部导航栏动态生成及浮动按钮与导航栏的融合","date":"2019-07-14T03:50:01.000Z","updated":"2019-07-19T08:34:29.835Z","comments":true,"path":"2019/07/14/13.Flutter底部导航栏动态生成及浮动按钮与导航栏的融合/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/14/13.Flutter底部导航栏动态生成及浮动按钮与导航栏的融合/","excerpt":"","text":"Flutter 底部导航栏动态生成及浮动按钮与导航栏的融合 相较上一篇的内容，这一篇我们不用硬编码四个页面，我们通过动态生成的方式生成需要的四个页面，另外增加一个可交互的浮动按钮与导航栏进行融合。 main.dart 文件 1234567891011121314151617import 'package:flutter/material.dart';import 'Navigation/bottom_navigation_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primaryColor: Colors.white, ), home: BottomNavigationBarWidget(), ); &#125;&#125; bottom_navigation_bar.dart 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import 'package:demo02/Navigation/dynamic_page.dart';import 'package:flutter/material.dart';class BottomNavigationBarWidget extends StatefulWidget &#123; @override _BottomNavigationBarWidgetState createState() =&gt; _BottomNavigationBarWidgetState();&#125;class _BottomNavigationBarWidgetState extends State&lt;BottomNavigationBarWidget&gt; &#123; //底部导航图标的颜色 final _bottomNavigationBarColor = Colors.white; //存放初始化的页面 List&lt;Widget&gt; _dynamicPageList; //当前所处的页面编号 int _index = 0; @override void initState() &#123; _dynamicPageList = List(); _dynamicPageList..add(DynamicPage('主页'))..add(DynamicPage('博客'))..add(DynamicPage('信息'))..add(DynamicPage('我的')); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: _dynamicPageList[_index], //定义可交互的浮动按钮 floatingActionButton: FloatingActionButton( backgroundColor: Colors.green, onPressed: ()&#123; //通过 路由组件 结合 动态创建页面 创建一个新的页面。 Navigator.of(context).push(MaterialPageRoute( builder:(BuildContext context)&#123; return DynamicPage('新增博客'); &#125; )); &#125;, //长按该按钮显示的提示内容 tooltip: '点击可添加博客', child: Icon( Icons.add, color: _bottomNavigationBarColor, ), ), //使用 Scaffold 中的 FloatingActionButtonLocation 让浮动按钮于底部导航进行融合 floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, //添加脚手架中的底部导航，底部导航中放置我们的工具栏，比之前的更加灵活 bottomNavigationBar: BottomAppBar( //给工具栏定义颜色 color: Colors.green, //给工具栏加一个圆形缺口，方便和我们定义的可交互浮动按钮进行融合 shape: CircularNotchedRectangle(), child: Row( mainAxisSize: MainAxisSize.max, mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ //主页 IconButton( icon: Icon(Icons.home), color: _bottomNavigationBarColor, onPressed: ()&#123; setState(() &#123; _index = 0; &#125;); &#125;, ), //博客 IconButton( icon: Icon(Icons.dns), color: _bottomNavigationBarColor, onPressed: ()&#123; setState(() &#123; _index = 1; &#125;); &#125;, ), //信息 IconButton( icon: Icon(Icons.mail), color: _bottomNavigationBarColor, onPressed: ()&#123; setState(() &#123; _index = 2; &#125;); &#125;, ), //我的 IconButton( icon: Icon(Icons.record_voice_over), color: _bottomNavigationBarColor, onPressed: ()&#123; setState(() &#123; _index = 3; &#125;); &#125;, ), ], ), ), ); &#125;&#125; dynamic_page.dart 代码 12345678910111213141516171819202122232425import 'package:flutter/material.dart';class DynamicPage extends StatefulWidget &#123; //定义一个变量存储传过来的 title 内容 String _title; //构造函数实现传入的内容赋值给定义的变量 DynamicPage(this._title); @override _DynamicPageState createState() =&gt; _DynamicPageState();&#125;class _DynamicPageState extends State&lt;DynamicPage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( //将传过来的参数赋值给相关的组件 appBar: AppBar(title: Text(widget._title),), body: Center(child:Text(widget._title)), ); &#125;&#125; 效果展示 2019/7/14:纵情山河万里，肆意九州五岳。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"10.Flutter导航参数传递与接收","slug":"10.Flutter导航参数传递与接收","date":"2019-07-13T03:50:01.000Z","updated":"2019-07-19T08:33:06.532Z","comments":true,"path":"2019/07/13/10.Flutter导航参数传递与接收/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/13/10.Flutter导航参数传递与接收/","excerpt":"","text":"Flutter 导航参数传递与接收 可以通过在 VS Code 中安装 Awesome Flutter Snippets 插件，快速生成部分代码，提高开发效率。比如下面在编写 ProductDetail 类和 ProductList 类时，只需输入stlss ，然后回车就可以快速生成一个模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import 'package:flutter/material.dart';class Product&#123; final String name; final String number; Product(this.name,this.number);&#125;void main()&#123; runApp( MaterialApp( title: '骚练编号列表', home: ProductList( products: List.generate( 20, (i) =&gt; Product('骚练 $&#123;i+1&#125; 号!','这是骚练 $&#123;i+1&#125; 号，欢迎享用!!!')), ), ) );&#125;class ProductList extends StatelessWidget &#123; //定义变量并添加构造函数 final List&lt;Product&gt; products; ProductList(&#123;Key key, @required this.products&#125;):super(key:key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('骚练列表'),), body: ListView.builder( itemCount: products.length, itemBuilder: (context,index)&#123; return ListTile( title: Text(products[index].name), onTap: ()&#123; Navigator.push( context, MaterialPageRoute( //传递参数时通过之前写好的构造函数传递，并用变量进行表示，前面为变量，后面时需要传递的内容 builder: (context) =&gt; ProductDetail(product:products[index]) ), ); &#125;, ); &#125; ), ); &#125;&#125;class ProductDetail extends StatelessWidget &#123; final Product product; ProductDetail(&#123;Key key, @required this.product&#125;):super(key:key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('鸭子详情'),), body: Center( child: Text('$&#123;product.number&#125;'), ) ); &#125;&#125; 效果展示 2019/7/13:关山万里路，拔剑起长歌。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"11.Flutter导航参数传递与接收2","slug":"11.Flutter导航参数传递与接收2","date":"2019-07-13T03:50:01.000Z","updated":"2019-07-19T08:33:37.944Z","comments":true,"path":"2019/07/13/11.Flutter导航参数传递与接收2/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/13/11.Flutter导航参数传递与接收2/","excerpt":"","text":"Flutter 导航参数传递与接收2 这里主要是接着上一篇的参数传递进行内容的回显，注意这里的异步请求方式，使用 async。另外后面补充一个引入项目文件的图片方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import 'package:flutter/material.dart';void main()&#123; runApp( MaterialApp( title: '跳转并返回数据', home: FirstPage(), ) );&#125;class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('查看鸭子'),), body: RouteButton(), ); &#125;&#125;class RouteButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: ()&#123;_navigateToDuck(context);&#125;, child: Text('To Find Your Lovely Duck'), ); &#125; //用下划线一般时内部的方法 //async 异步请求并返回数据 _navigateToDuck(BuildContext context) async&#123; final result = await Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; DuckPage() )); //通过 Scafflod 的 SnackBar 回显返回的数据 Scaffold.of(context).showSnackBar(SnackBar(content:Text('$result'))); &#125;&#125;class DuckPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('Duck Page'),), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text('骚练'), onPressed: ()&#123; Navigator.pop(context,'天字第一号，骚练，动感热线：13888888888'); &#125;, ), RaisedButton( child: Text('麻子'), onPressed: ()&#123; Navigator.pop(context,'地字第一号，骚麻，动感热线：13333333333'); &#125;, ), RaisedButton( child: Text('亦肥'), onPressed: ()&#123; Navigator.pop(context,'玄字第一号，亦肥，动感热线：18888888888'); &#125;, ), RaisedButton( child: Text('旺仔'), onPressed: ()&#123; Navigator.pop(context,'黄字第一号，旺仔，动感热线：13999999999'); &#125;, ) ], ), ), ); &#125;&#125; 效果展示 第一步在中进行引入图片的路径，比如我们创建文件夹 images 并存入 avatar.jpg 图片，我们需要先在 pubspec.yaml 文件中使用 assets 引入，然后在通过 Image.asset() 引用图片，这里有一个坑点，是 yaml 中必须按层级关系将语法对齐，否则就会出错，如下面的 assets: 需要与上面的 uses-material-design: true 对齐才行。123456789101112131415 # The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # To add assets to your application, add an assets section, like this: # assets: # - images/a_dot_burr.jpeg # - images/a_dot_ham.jpeg assets: - images/avatar.jpg 123456789101112import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( child: Image.asset('images/avatar.jpg'), ); &#125;&#125; 效果图如下： 2019/7/13:生活是一种飞行，四季是爱的衬景。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"12.Flutter底部导航栏和切换效果","slug":"12.Flutter底部导航栏和切换效果","date":"2019-07-13T03:50:01.000Z","updated":"2019-07-19T08:34:02.535Z","comments":true,"path":"2019/07/13/12.Flutter底部导航栏和切换效果/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/13/12.Flutter底部导航栏和切换效果/","excerpt":"","text":"Flutter 制作底部导航栏和切换效果 利用 Flutter 的 BottomNavigationBar 实现底部导航栏，这里将慢慢创建特定的包放置相关的组件，不会什么都写在一个文件里面。 首先来看底部导航栏的设置 main.dart 文件 123456789101112131415161718import 'package:flutter/material.dart';//这里的 navigation 文件夹就是自己在 lib 目录创建的import 'navigation/bottom_navigation_widget.dart';//创建主入口程序，加载我们的 MyApp()void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: \"Blog Software\", theme: ThemeData.light(), //自定义的组件，在 navigation 包下 home: BottomNavigationWidget(), ); &#125;&#125; BottomNavigationWidget 组件代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';//此处使用 awesome Flutter Snippets 插件利用快速生成方式（stful）生成下面的 BottomNavigationWidget 和 _BottomNavigationWidgetState 模板class BottomNavigationWidget extends StatefulWidget &#123; @override _BottomNavigationWidgetState createState() =&gt; _BottomNavigationWidgetState();&#125;class _BottomNavigationWidgetState extends State&lt;BottomNavigationWidget&gt; &#123;//定义底部导航组件的颜色final Color _bottomNavigationWidgetColor = Colors.purpleAccent; @override Widget build(BuildContext context) &#123; return Scaffold( bottomNavigationBar: BottomNavigationBar( items: [ //主页组件 BottomNavigationBarItem( icon: Icon( Icons.home, color: _bottomNavigationWidgetColor, ), title: Text( '主页', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //博客组件 BottomNavigationBarItem( icon: Icon( Icons.dns, color: _bottomNavigationWidgetColor, ), title: Text( '博客', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //信息组件 BottomNavigationBarItem( icon: Icon( Icons.mail, color: _bottomNavigationWidgetColor, ), title: Text( '信息', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //我的 组件 BottomNavigationBarItem( icon: Icon( Icons.record_voice_over, color: _bottomNavigationWidgetColor, ), title: Text( '我的', style: TextStyle(color: _bottomNavigationWidgetColor), ), ) ], ), ); &#125;&#125; 效果展示 接下来才是今天学习的有意思的东西，我们在 lib 文件夹下新建一个 navigation_pages 文件夹，专门用来存导航栏点击过后的页面，并在里面创建 home_page.dart , blog_page.dart , message_page.dart , my_page.dart 四个文件，分别放置主页，博客，信息，我的四个底部导航对应的页面。下面直接将代码放出来，最后的点击动画效果还是很好的。 main.dart 1234567891011121314151617import 'package:flutter/material.dart';import 'navigation/bottom_navigation_widget.dart';//创建主入口程序，加载我们的 MyApp()void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: \"Blog Software\", theme: ThemeData.light(), //自定义的组件，在 navigation 包下 home: BottomNavigationWidget(), ); &#125;&#125; bottom_navigation_widget.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import 'package:flutter/material.dart';import 'package:demo1/navigation_pages/home_page.dart';import 'package:demo1/navigation_pages/blog_page.dart';import 'package:demo1/navigation_pages/message_page.dart';import 'package:demo1/navigation_pages/my_page.dart';//此处使用 awesome Flutter Snippets 插件利用快速生成方式（stful）生成下面的 BottomNavigationWidget 和 _BottomNavigationWidgetState 模板class BottomNavigationWidget extends StatefulWidget &#123; @override _BottomNavigationWidgetState createState() =&gt; _BottomNavigationWidgetState();&#125;class _BottomNavigationWidgetState extends State&lt;BottomNavigationWidget&gt; &#123; //定义底部导航组件的颜色 final Color _bottomNavigationWidgetColor = Colors.purpleAccent; //创建一个记录当前变量用来保存当前是在那个底部导航上,初始化使其在第一个上，即 0 int _currentIndex = 0; //将创建好的四个底部导航栏初始化进一个 list ，方便后面进行切换,因为所有的页面实际都是相关的组件，所以 List 我们指定一个类型就是 Widget List&lt;Widget&gt; bottomNavigationBarList = List(); //对 List 进行初始化，需要重写 State 的 Init() 方法 @override void initState() &#123; // 将四个页面组件加入 List ，这里用完 .. 返回的还是那个 List ,就可以一直 add 了。 bottomNavigationBarList ..add(HomePage()) ..add(BlogPage()) ..add(MessagePage()) ..add(MyPage()); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( //将主页内容加入脚手架 body: bottomNavigationBarList[_currentIndex], bottomNavigationBar: BottomNavigationBar( //将默认的页面或者是我们点击过后的页面下标赋值给 BottomNavigationBar 的 currentIndex 属性。 currentIndex: _currentIndex, //添加点击实践，这里的 index 是系统默认就有的，直接拿来用就行。 onTap: (int index)&#123; setState(() &#123; _currentIndex = index; &#125;); &#125;, items: [ //主页组件 BottomNavigationBarItem( icon: Icon( Icons.home, color: _bottomNavigationWidgetColor, ), title: Text( '主页', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //博客组件 BottomNavigationBarItem( icon: Icon( Icons.dns, color: _bottomNavigationWidgetColor, ), title: Text( '博客', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //信息组件 BottomNavigationBarItem( icon: Icon( Icons.mail, color: _bottomNavigationWidgetColor, ), title: Text( '信息', style: TextStyle(color: _bottomNavigationWidgetColor), ), ), //我的 组件 BottomNavigationBarItem( icon: Icon( Icons.record_voice_over, color: _bottomNavigationWidgetColor, ), title: Text( '我的', style: TextStyle(color: _bottomNavigationWidgetColor), ), ) ], ), ); &#125;&#125; home_page.dart 12345678910111213import 'package:flutter/material.dart';class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('主页'),), body: Center( child: Text('主页内容'), ) ); &#125;&#125; blog_page.dart 12345678910111213import 'package:flutter/material.dart';class BlogPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('博客'),), body: Center( child: Text('博客内容'), ) ); &#125;&#125; message_page.dart 12345678910111213import 'package:flutter/material.dart';class MessagePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('信息'),), body: Center( child: Text('信息内容'), ) ); &#125;&#125; my_page.dart 12345678910111213import 'package:flutter/material.dart';class MyPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('我的'),), body: Center( child: Text('我的相关内容'), ) ); &#125;&#125; 效果图： 2019/7/13:圆荷浮小叶，细麦落轻花。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"8.Flutter初体验卡片布局","slug":"8.Flutter初体验卡片布局","date":"2019-07-12T03:50:01.000Z","updated":"2019-07-19T08:32:08.307Z","comments":true,"path":"2019/07/12/8.Flutter初体验卡片布局/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/12/8.Flutter初体验卡片布局/","excerpt":"","text":"Flutter 卡片布局 Card实现卡片布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart';import 'package:flutter/rendering.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; var card = new Card( child: Column( children: &lt;Widget&gt;[ ListTile( title: Text('中国金科',style:TextStyle(fontWeight: FontWeight.w500)), subtitle: Text('麻子哥'), leading: Icon(Icons.account_box, color: Colors.lightBlue,), ), //加入一个分割线显得更好看一点，初学实践 new Divider(), ListTile( title: Text('福建网龙',style:TextStyle(fontWeight: FontWeight.w500)), subtitle: Text('宋吉吉'), leading: Icon(Icons.account_box, color: Colors.lightBlue,), ), new Divider(), ListTile( title: Text('腾讯',style:TextStyle(fontWeight: FontWeight.w500)), subtitle: Text('旺仔'), leading: Icon(Icons.account_box, color: Colors.lightBlue,), ), new Divider(), ListTile( title: Text('方特公园',style:TextStyle(fontWeight: FontWeight.w500)), //副标题 subtitle: Text('傲翊'), leading: Icon(Icons.account_box, color: Colors.lightBlue,), ), //这里貌似超过屏幕大小就会报错，暂时不加太多，后面继续学习看一下有没有什么好的解决方法 // ListTile( // title: Text('迷你玩',style:TextStyle(fontWeight: FontWeight.w500)), // subtitle: Text('一尺'), // leading: Icon(Icons.account_box, color: Colors.lightBlue,), // ), // ListTile( // title: Text('孚佑传媒',style:TextStyle(fontWeight: FontWeight.w500)), // subtitle: Text('启航'), // leading: Icon(Icons.account_box, color: Colors.lightBlue,), // ), ], ), ); return MaterialApp( title: \"Stack Demo\", home: Scaffold( appBar: new AppBar(title: new Text('联系人卡片'),), body: Center( child: card, ), ) ); &#125;&#125; 效果展示 2019/7/12:今天工头给我说，达者为师，我又学会了新词。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"9.Flutter导航组件","slug":"9.Flutter导航组件","date":"2019-07-12T03:50:01.000Z","updated":"2019-07-19T08:32:41.625Z","comments":true,"path":"2019/07/12/9.Flutter导航组件/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/12/9.Flutter导航组件/","excerpt":"","text":"Flutter 导航组件 Navigate实现导航1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import 'package:flutter/material.dart';void main()&#123; runApp( MaterialApp( title: '导航演示', home: new FirstScreen(), ) );&#125;class FirstScreen extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return Scaffold( appBar: AppBar(title: Text('导航页面'),), body: Center( child: RaisedButton( child: Text('查看商品详情页'), onPressed: ()&#123; //实现导航，并通过 MaterialPageRoute 进行路由 到其他页面 Navigator.push(context, MaterialPageRoute( builder: (context) =&gt; SecondPage(), )); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return Scaffold( appBar: AppBar(title: Text('商品详情页'),), body: Center( child: RaisedButton( child: Text('返回上一页'), onPressed: ()&#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 效果展示 2019/7/12:今天工头给我说，达者为师，我又学会了新词。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"3.Flutter初体验ListView组件浅尝","slug":"3.Flutter初体验ListView组件浅尝","date":"2019-07-09T03:50:01.000Z","updated":"2019-07-19T08:28:02.222Z","comments":true,"path":"2019/07/09/3.Flutter初体验ListView组件浅尝/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/09/3.Flutter初体验ListView组件浅尝/","excerpt":"","text":"Flutter初体验ListView组件浅尝 ListView组件的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: new Text(\"HickSalmon's App\")), // ListView 的简单使用 Tile 瓦片的意思，内置图标很丰富，满足基本开发 body: new ListView( children: &lt;Widget&gt;[ new ListTile( // leading: new Icon(Icons.brightness_4), title: Text( ' 静夜思', textAlign: TextAlign.center, style: TextStyle( fontSize: 30, ), ), ), new ListTile( leading: new Icon(Icons.brightness_4), title: Text(' 床前明月光，', textAlign: TextAlign.justify, style: TextStyle( color: Colors.green, ),), ), new ListTile( leading: new Icon(Icons.cloud), title: Text(' 疑是地上霜。', textAlign: TextAlign.justify, style: TextStyle( color: Colors.green, ),), ), new ListTile( leading: new Icon(Icons.brightness_2), title: Text(' 举头望明月，', textAlign: TextAlign.justify, style: TextStyle( color: Colors.green, ),), ), new ListTile( leading: new Icon(Icons.directions_run), title: Text(' 低头思故乡。', textAlign: TextAlign.justify, style: TextStyle( color: Colors.green, ),), ), ], ), ), ); &#125;&#125; 效果展示 ListView变换使用图片123456789101112131415161718192021222324252627import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());//ListView 中也可以加入 图片class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: new Text(\"HickSalmon's App\")), body: new ListView( children: &lt;Widget&gt;[ new Image.network('https://icon-icons.com/icons2/1983/PNG/128/_123042.png'), new Text('--------------------分割线--------------------'), new Image.network('https://icon-icons.com/icons2/1983/PNG/128/_123042.png'), new Text('--------------------分割线--------------------'), new Image.network('https://icon-icons.com/icons2/1983/PNG/128/_123042.png'), new Text('--------------------分割线--------------------'), new Image.network('https://icon-icons.com/icons2/1983/PNG/128/_123042.png'), ], ), ), ); &#125;&#125; 这里是对 ListView 的实现水平展开，即利用 scrollDirection 的 Axis.horrizontal 属性实现水平铺展。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: Text(\"HickSalmon's App\"),), body: Container( height: 300, child: ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ new Container( width: 160, color: Colors.lightBlue, ), new Container( width: 160, color: Colors.green, ), new Container( width: 160, color: Colors.yellowAccent, ), new Container( width: 160, color: Colors.purple, ), new Container( width: 160, color: Colors.deepOrange, ), new Container( width: 160, color: Colors.deepPurple, ), ], ), ), ), ); &#125;&#125; 我们发现每次的代码都显得异常复杂，感觉嵌套的内容实在太多，实际在真实开发中，我们并不会嵌套这么多，而是会将一些组件提出来，如下面的例子,我们就将上面的内容进行提取，让代码显得不在那么臃肿复杂。这也是Flutter万事皆组件的思想体现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: Text(\"HickSalmon's App\"),), body: Container( height: 300, child: MyList(), ), ), ); &#125;&#125;class MyList extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return new ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ new Container( width: 160, color: Colors.lightBlue, ), new Container( width: 160, color: Colors.green, ), new Container( width: 160, color: Colors.yellowAccent, ), new Container( width: 160, color: Colors.purple, ), new Container( width: 160, color: Colors.deepOrange, ), new Container( width: 160, color: Colors.deepPurple, ), ], ); &#125; &#125; 2019/7/9：每天看点点还有点意思？","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"5.Flutter初体验GridView布局","slug":"5.Flutter初体验GridView布局","date":"2019-07-09T03:50:01.000Z","updated":"2019-07-19T08:30:37.998Z","comments":true,"path":"2019/07/09/5.Flutter初体验GridView布局/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/09/5.Flutter初体验GridView布局/","excerpt":"","text":"Flutter 初体验 GridView 布局 GridView实现网格布局，这里注意一下他的相关参数。 gridDelegate: SliverGridDelegateWithFixedCrossAxisCount 中上下左右的间距，以及每行显示的个数，还有宽高比。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import 'package:flutter/material.dart';import 'package:flutter/widgets.dart';//这里传了一个类型为 String 类型的 List 集合，传参时利用了 List 的 generate 方法生成了100个//item + 序号 的字符串放到 List 里面了。void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: Text(\"Photo Album\"),), body: GridView( padding: const EdgeInsets.all(5), //给网格授权相关的参数，字面意思 gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, //图片左右之间的距离 crossAxisSpacing: 5, //图片上下之间的距离 mainAxisSpacing: 5, //宽高比 childAspectRatio: 0.75 ), children: &lt;Widget&gt;[ // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), // new Image.network('http://cdn.ruoshuisanqian.site/22.jpg'), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover), new Image.network('http://cdn.ruoshuisanqian.site/22.jpg',fit:BoxFit.cover) ], ) ), ); &#125;&#125; 效果展示","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"4.Flutter初体验ListView动态列表","slug":"4.Flutter初体验ListView动态列表","date":"2019-07-09T03:50:01.000Z","updated":"2019-07-19T08:28:54.724Z","comments":true,"path":"2019/07/09/4.Flutter初体验ListView动态列表/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/09/4.Flutter初体验ListView动态列表/","excerpt":"","text":"Flutter初体验ListView动态列表 ListView的动态列表实践这节的实践内容主要是： dart 中的传参； dart 中构造函数的使用1234567891011121314151617181920212223242526272829303132import 'package:flutter/material.dart';import 'package:flutter/widgets.dart';//这里传了一个类型为 String 类型的 List 集合，传参时利用了 List 的 generate 方法生成了100个//item + 序号 的字符串放到 List 里面了。void main() =&gt; runApp(MyApp( items : new List&lt;String&gt;.generate(100, (i) =&gt; \"item $i\") ));class MyApp extends StatelessWidget&#123; final List&lt;String&gt; items; //固定写法，首先必须有 Key 值，然后 @required 要求调用 MyApp 必须传一个参数，用 items 接收 //最后需要将传过来的参数使用 super 给他赋值 MyApp(&#123;Key key,@required this.items&#125;):super(key:key); @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"HickSalmon\", home: Scaffold( appBar: new AppBar(title: Text(\"HickSalmon's App\"),), body: new ListView.builder( itemCount: items.length, itemBuilder: (context, index)&#123; return new ListTile( title: new Text('$&#123;items[index]&#125;'), ); &#125;, ) ), ); &#125;&#125; 效果展示 2019/7/9：今天多学了一点？","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"6.Flutter初体验Row及Colume布局","slug":"6.Flutter初体验Row及Colume布局","date":"2019-07-09T03:50:01.000Z","updated":"2019-07-19T08:30:49.917Z","comments":true,"path":"2019/07/09/6.Flutter初体验Row及Colume布局/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/09/6.Flutter初体验Row及Colume布局/","excerpt":"","text":"Flutter 水平与垂直布局 Row实现水平布局123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: 'Row Test Demo', home: Scaffold( appBar: new AppBar( title: new Text('水平布局'), ), body:new Row( children: &lt;Widget&gt;[ //这里的 Expended 可以让这三个 Button 自适应屏幕大小，平均分配,不使用就可能会挤出去 Expanded( child: new RaisedButton( color: Colors.redAccent, onPressed: ()&#123;&#125;, child: new Text('Red Button'), ), ), Expanded( child: new RaisedButton( color: Colors.purpleAccent, onPressed: ()&#123;&#125;, child: new Text('PurpleAccent Button'), ), ), Expanded( child: new RaisedButton( color: Colors.lightBlue, onPressed: ()&#123;&#125;, child: new Text('LightBlue Button'), ), ), ],), ), ); &#125;&#125; 效果展示 Colume实现垂直布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: 'Colume Text', home: Scaffold( appBar: new AppBar(title: new Text('垂直布局'),), //这里的 Center 可以实现将整个 child 内容放置在中间 body: Center( child:new Column( //这里通过设置水平和垂直方向的布置方向可以实现内容所占区域的水平和垂直放置 //所占区域指的是 children 中元素内容最长的那个所占的区域 // crossAxisAlignment: CrossAxisAlignment.center, // mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text('我是中国人，我爱中国'), RaisedButton( color: Colors.lightBlue, onPressed: ()&#123;&#125;, child: new Text('博客管理'), ), RaisedButton( color: Colors.pinkAccent, onPressed: ()&#123;&#125;, child: new Text('关注管理'), ), RaisedButton( color: Colors.lightBlue, onPressed: ()&#123;&#125;, child: new Text('博客管理'), ), RaisedButton( color: Colors.redAccent, onPressed: ()&#123;&#125;, child: new Text('评论管理'), ), ], ), ) ), ); &#125;&#125; 效果展示","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"7.Flutter初体验层叠布局","slug":"7.Flutter初体验层叠布局","date":"2019-07-09T03:50:01.000Z","updated":"2019-07-19T08:31:40.334Z","comments":true,"path":"2019/07/09/7.Flutter初体验层叠布局/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/09/7.Flutter初体验层叠布局/","excerpt":"","text":"Flutter 层叠布局 Stack实现层叠布局1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';import 'package:flutter/rendering.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; //定义一个层叠布局，适合两个类容的层叠，通过 FractionalOffset 设置两个的偏移量，注意这里的偏移量在 0 和 1 之间。 var stack = new Stack( alignment: const FractionalOffset(0.45, 0.5), children: &lt;Widget&gt;[ //创建一个原型头像 new CircleAvatar( backgroundImage:new NetworkImage('http://cdn.ruoshuisanqian.site/头像.jpg'), radius: 100.0, ), new Container( decoration:new BoxDecoration( color: Colors.deepOrange ), padding: EdgeInsets.all(5.0), child: Text('当事人懵逼中...'), ) ], ); return MaterialApp( title: \"Stack Demo\", home: Scaffold( appBar: new AppBar(title: new Text('层叠布局'),), body: Center( child: stack, ), ) ); &#125;&#125; 效果展示","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"2.Flutter初体验Text与Image组件浅尝","slug":"2.Flutter初体验Text与Image组件浅尝","date":"2019-07-08T03:50:01.000Z","updated":"2019-07-09T13:07:31.504Z","comments":true,"path":"2019/07/08/2.Flutter初体验Text与Image组件浅尝/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/08/2.Flutter初体验Text与Image组件浅尝/","excerpt":"","text":"Flutter初体验Text与Image组件浅尝 Text 组件熟悉textAlign（对其方式），maxLines（最大行数），overflow（超过当前这行的怎么处理显示），style（对字体的属性进行设置，包括（字体大小，颜色，下划线，下划线的属性等等，可具体查阅相关文档进行使用））。12345678910111213141516171819202122232425import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; //比如新闻列表就可能经常用这个，这个主要是文本的对齐方式 //主要是对 Text 属性的使用 child: Text( '床前明月光，疑是地上霜。举头望明月，低头思故乡。', textAlign: TextAlign.left, maxLines: 1, overflow: TextOverflow.ellipsis, style: TextStyle( fontSize: 24, color: Color.fromARGB(255, 255, 125, 125), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid, ), ), ), ), ), ); &#125;&#125; 当然 Text 属性还有很多，如下面的 alignment（主要是显示的位置），padding（内边距），margin（外边距），decoration（以及很强大的装饰属性，这个可以实现渐变的效果，其自身相关属性也可以查阅相关文档）。12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: 'Hello Widget', home: Scaffold( body: Center( child: Container( child: Text( 'HickSalmon', style: TextStyle( fontSize: 40.0, // color: Color.fromARGB(255, 255, 0, 0), ),), // alignment: Alignment.bottomRight, alignment: Alignment.topLeft, width: 400, height: 300, // color: Colors.lightBlue, padding: const EdgeInsets.fromLTRB(10, 20, 0, 0), margin: const EdgeInsets.all(10), decoration: new BoxDecoration( gradient: const LinearGradient( colors: [Colors.lightBlue,Colors.green,Colors.purple], ), border: Border.all(width: 10,color:Colors.red ), ), ), ), ), ); &#125;&#125; 最后是对 Image 组件的尝试，图片的加载方式很多，最常用的就是 Image.network() ，加载网络图片（这里当时自己测试的时候网了给网址加引号，一直报错我都懵了。2333。。。。），以及对图片的相关处理。123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: \"图片加载\", home: Scaffold( body: Center( child: Container( //Image.network() 使用网络的图片，开发常用的方式 child: new Image.network( 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=655260795,2787721540&amp;fm=27&amp;gp=0.jpg', //fit属性就是填充的方式，可以 BoxFit.fill （根据容器拉满可能变形） BoxFit.Width（根据水平的拉满） // BoxFit.Height（按高度拉满） BoxFit.contain （按照图片的大小拉满，不改变图片的宽高比） // fit: BoxFit.fitWidth, // fit: BoxFit.fitHeight, // fit: BoxFit.contain, fit: BoxFit.fill, color: Colors.green, //混合属性 colorBlendMode: BlendMode.darken, //重复属性 // repeat: ImageRepeat.repeat, ), width: 300, height: 200, color: Colors.lightBlue, ), ), ), ); &#125;&#125; 最后是对之前的多余操作进行一个补充，昨天学习的利用批处理文件启动虚拟机，显得有点多余，实际在 VS Code 中，在安装完 Flutter 与 Dart 插件之后，在 IDE 的右下角点击那个 No device 就可以自己添加虚拟机或者创建相关的虚拟机了。 2019/7/8：今天没什么感想，但是为了这里有句话，我就写这个。还有今天写完这个总结已经11点了。握草！","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"1.Flutter初体验踩坑记录","slug":"1.Flutter初体验踩坑记录","date":"2019-07-07T03:50:01.000Z","updated":"2019-07-19T08:26:50.122Z","comments":true,"path":"2019/07/07/1.Flutter初体验踩坑记录/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/07/1.Flutter初体验踩坑记录/","excerpt":"","text":"Flutter第一次采坑记录 由于Android Studio 实在过于慢了，我们在学习 Flutter 的时候，可以换用 VS Code 进行开发。 而采用 VS Code 开发时，启动我们的虚拟机，我们可以自己写一个 windows 的批处理文件来启动虚拟机。之前我们安装过虚拟机，我们只需要在 AS 中查看 AVD Manager 中的虚拟机名称记住，接下来写一个 .bat 的脚本文件，在桌面建立一个任意名字的 xxx.bat 文件，找到 emulator.exe 的文件路径，在里面添加简单的脚本，如我的如下： 1E:\\AndroidSDK\\emulator\\emulator.exe -netdelay none -netspeed full -avd YaErYo 前面是 emulator.exe 的文件路径，-netdelay none 是设置网络延迟为 0 ，-netspeed full 是设置网络速度为全速，-avd YaErYo 是之前在 Android Studio 中下载的虚拟机的名字，不知道可以打开 AS 进行查看，这里注意的是如果虚拟机的名字有空格，我们需要将空格换成下划线，否则会报错。我这里的名字叫 YaErYo 没有下划线就不用管。 当我们使用 VS Code 进行开发的时候，首先使用管理员权限运行我们之前建立的的 xxx.bat 脚本启动虚拟机，然后在 VS Code 中使用 Ctrl + ~ 调起命令行工具，使用 flutter run 命令进行启动 flutter 程序，这样的目的是方便我们，在后续的过程中，使用快捷键 o 快速切换 IOS 界面 和 Android 界面视图；使用快捷键 p 显示虚拟机视图的网格，方便我们调试； 使用快捷键 r 实现热更新。 2019/7/7：家是温暖的港湾，需要的是温度，不是压力，善待最亲近的人。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/Flutter/"}]},{"title":"日志","slug":"日志","date":"2019-07-06T03:50:01.000Z","updated":"2019-07-19T08:43:42.722Z","comments":true,"path":"2019/07/06/日志/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/06/日志/","excerpt":"","text":"日志JCL组件结构图适配器模式 为了解决 jcl 的不足出现了 slf4j ， jcl 通过源码发现，他是采用的一个适配器模式，动态的去决定使用哪种日志，而 slf4j 不一样，他是采用的一种静态桥接方式，是用什么日志，就需要自己添加相应的桥接。对于slf4j的简介如下： 具体的桥接见下图: 这里注意只有老版的 spring 是用的 jcl ，新版的 spring 并不是采用 jcl 实现的。 出现这种问题，解决方案有两种1）直接将app中的日志桥接到log4j，即加一个slf4j-log4j12 的桥接器；2）是通过一个替换器（jcl-over-slf4j）将jcl替换掉，来用 slf4f 的，即使用 log4j2 . 同理其他的日志在slf4j中也可以替换成功，替换方法如下： 这个时候要注意一点就是不要，同时使用一种日志实现的适配和桥接，不然就会进入一个死循环，运行就会报一个 StackOverflowError ，堆栈溢出的错误。如下图： 最后放一张简单的 log4j2.xml 的配置文件。 2019/7/6：生活的主题就是，面对复杂，保持欢喜。","categories":[{"name":"日志","slug":"日志","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/日志/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/日志/"}]},{"title":"3. jenkins学习--持续集成01","slug":"3.Jenkins学习--持续集成01","date":"2019-07-02T03:50:01.000Z","updated":"2019-07-19T08:28:29.954Z","comments":true,"path":"2019/07/02/3.Jenkins学习--持续集成01/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/07/02/3.Jenkins学习--持续集成01/","excerpt":"","text":"3. Jenkins学习–持续集成01 1.jenkins安装jenkins安装方式很多，在这里我采用的是将 jenkins 的 war 放入 tomcat 中运行来安装的 jenkins 。官网下载 jenkins war 包。 https://jenkins.io/zh/download/利用Xftp 6 上传 war 至 tomcat 的 webapp 目录，运行 tomcat （./bin/startup.sh）根据提示进行后续安装，选择插件安装的时候，选择默认的插件进行安装。2.jenkins JDK 配置JDK需要注意在服务器中需要配置环境变量， /etc/profile 中进行配置3.jenkins Maven 配置maven需要注意在服务器中需要配置环境变量， /etc/profile 中进行配置 4.jenkins git 配置 5.项目建立与码云打通如果是私有项目需要添加代码托管平台的账号和密码，才能拉取代码。6.使用 执行shell 实现持续集成 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; #!/bin/bash&gt; source /etc/profile&gt; tomcat_path=/usr/tomcat/apache-tomcat-8.5.38/webapps&gt; #war包路径 及 名称&gt; war_path=/root/.jenkins/workspace/conformity/target/firstone.war&gt; war_name=conformity.war&gt; war_file=$&#123;war_path&#125;$&#123;war_name&#125;&gt; #从git中下载的源码路径&gt; #$&#123;JENKINS_HOME&#125; 为全局变量 请事先查看 有没有声明没有在 在/etc/profile中声明&gt; #export JENKINS_HOME=/opt/run_/tomcat/tomcat8-7979/webapps/jenkins&gt; source_path=$&#123;JENKINS_HOME&#125;/workspace/conformity&gt; #su root&gt; #xtj1008611&gt; echo \"切换到root用户成功\"&gt; cd root/.jenkins/jobs/conformity&gt; #日志所在路径&gt; log_file=$&#123;JENKINS_HOME&#125;\"/build_log.log\"&gt; echo \"一个大西瓜\" $&#123;log_file&#125;&gt; #定义一个函数 用来写入log文件&gt; writeLogFun()&#123;&gt; if [ ! -e $log_file ]&gt; then&gt; echo \"文件不存在 新建一个\"&gt; touch $&#123;log_file&#125;&gt; fi&gt; nowtime=`date +%Y%m%d%H%M%S`&gt; echo $nowtime$1 &gt;&gt; $log_file&gt; &#125;&gt; writeLogFun \"开始执行 mvn install命令当前路径$(pwd)\"&gt; #mvn install&gt; mvn package&gt; echo $&#123;war_file&#125;&gt; su root&gt; xtj100861&gt; mv $&#123;war_path&#125; $&#123;tomcat_path&#125;&gt; echo \"两个大西瓜\" $&#123;tomcat_path&#125;&gt; sleep 1s&gt; writeLogFun \"tomcat 进行重启\"&gt; cd $&#123;tomcat_path&#125;&gt; ll&gt; cd ..&gt; ./bin/startup.sh&gt; echo [-e $&#123;war_file&#125;]&gt; echo \"好像是成功了\"&gt; 打包的时候可能出现找不到 xml 文件的情况。 org.springframework.beans.factory.BeanDefinitionStoreException: Could not resolve bean definition resource pattern [classpath:spring/applicationContext-*.xml]; nested exception is java.io.FileNotFoundException: class path resource [spring/] cannot be resolved to URL because it does not exist 此时是因为默认 maven 不扫描 xml文件，我们需要在 pom 文件中申明 123456789101112&gt; &lt;build&gt; &gt; &lt;resources&gt;&gt; &lt;resource&gt;&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&gt; &lt;includes&gt;&gt; &lt;include&gt;**/*.properties&lt;/include&gt;&gt; &lt;include&gt;**/*.xml&lt;/include&gt;&gt; &lt;/includes&gt;&gt; &lt;filtering&gt;false&lt;/filtering&gt;&gt; &lt;/resources&gt;&gt; &lt;/build&gt;&gt; shell 脚本能力还不够，需要加强，这里将之前的项目简单的上传打包，并发布成功了。具体的 shell 还得具体对待。 2019/7/2：今天骚练在我家，明天他就回家了，我继续上班，不久的将来他去福建农林大学读研究生。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/持续集成/"}]},{"title":"2.jenkins学习--虚拟机坑点2","slug":"2.Jenkins学习--虚拟机坑点2","date":"2019-06-22T06:50:01.000Z","updated":"2019-07-19T08:26:37.755Z","comments":true,"path":"2019/06/22/2.Jenkins学习--虚拟机坑点2/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/06/22/2.Jenkins学习--虚拟机坑点2/","excerpt":"","text":"2. Jenkins学习–虚拟机坑点2 少了一些图形库文件引发一些故事 我在 VMware Workstation 装的是Ubuntu 16.04 server iso ，以至于差一些支持图形界面的库，当我想要安装jenkins时，出现了今天的第一个坑点，出现关于 AWT 的错误： java.lang.UnsatisfiedLinkError: /mnt/jdk1.8/jre/lib/amd64/libawt_xawt.so: libXtst.so.6: cannot open shared object file: No such file or directory 百度了一下，需要安装，命令如下： apt-get install libxrender-dev apt-get install libxtst-dev 至此出现第二个关于虚拟机客户端的坑点（动态IP让我虚拟机不能上网了）。首先了解了一下 VMWare Workstation中几种联网方式：(1) Bridged: Connected directly to the physical network，使用桥接网卡（VMnet0虚拟网卡），表示当前虚拟机与主机（指运行VMware Workstation软件的计算机）在同一个网络中;(2) NAT: Used to share the host’s IP address，使用NAT网卡（VMnet8虚拟网卡），表示虚拟机通过主机单向访问主机及主机之外的网络，主机之外的网络中的计算机，不能访问该虚拟机;(3) Host-only： A private network shared with the host，只使用本地网络（VMnet1虚拟网卡），表示虚拟机只能访问主机及所有使用VMnet1虚拟网卡的虚拟机。主机之外的网络中的计算机不能访问该虚拟机，也不能被该虚拟机所访问；(4) Custom: Specific virtual network，没有网络连接，表明该虚拟机与主机没有网络连接。# 而我前一天使用的时桥接模式,我的笔记本使用的又是 wifi ，路由器现在基本都是动态 IP ，基于此，前一天虚拟机客户端还能上网，今天不能上网了，可能就是虚拟机中默认使用了之前的 IP ，现在主机 IP 改变，他却没变，使得虚拟机不能上网了。于是在这里我就将联网模式改成 NAT 模式了，然后重启客户端就可以让虚拟机上网了。重启很重要，最后通过 ifconfig 查看分配给客户端的 IP ，使用Xshell 就可以上网了。 2019/6/22：打开窗户让孤单透气，这一间屋子如此密闭，欢呼声仍飘在空气里，想空无一人的华丽。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/持续集成/"}]},{"title":"1. jenkins学习--虚拟机坑点1","slug":"1.Jenkins学习--虚拟机坑点","date":"2019-06-21T03:50:01.000Z","updated":"2019-07-19T08:27:39.455Z","comments":true,"path":"2019/06/21/1.Jenkins学习--虚拟机坑点/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/06/21/1.Jenkins学习--虚拟机坑点/","excerpt":"","text":"1.Jenkins学习–虚拟机坑点1 买不起服务器就虚拟机来凑 VMware Workstation 作为一种在桌面可以运行多种操作系统的虚拟计算机软件，首当其冲的要第一个搞定。这个的安装，我是之前安装好的没有什么记忆了，在此不做什么坑点的记录了。 Ubuntu 系统的安装坑点 从官网下载好了Ubuntu 16.04 server iso 镜像，server 镜像地址见 https://ubuntu.com/download/alternative-downloads ，可自由选择相关的版本； 在 VM 中进行安装，参照教程（具体操作我已经截图放在总结之后，即最后的截图），源地址： https://www.cnblogs.com/Alier/p/6337151.html 不过这里我下载的是 server ，在这里遇到几个坑点。 （1）. 安装过程中语言需要选择英文，否则在后续的安装过程中会出现语言包的问题，或者在安装完成时会出现乱码的问题。这个就很烦，应该有办法解决但是我没深入了解； （2）.默认下载的ubuntu系统镜像源是 us 。所以会出现下载其他东西时很慢的现象，这个可以通过换镜像源的方式进行改进。 镜像更改如下操作： #利用vim修改镜像源配置vim /etc/apt/sources.list#替换为阿里的镜像源deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse#更新sudo apt-get update 3.我们平时可能用Xshell或者其他的远程连接工具更多，所以我们在这里安装好虚拟机之后一样用远程连接工具进行连接，这个时候往往会出现另一个比较坑的就是，发现用工具连不上，我在这里就出现了，原因是我的ubuntu没有支持 SSH ，所以在这里需要安装 SSH（安装过程不赘述）；4.最后想要记录的是关于系统与虚拟机中如何实现文件共享的，我们可以在系统的某个盘中建立一个共享文件夹，然后在虚拟机中设置为共享文件夹。详情见下图：系统的共享文件夹虚拟机软件设置命令行查看到的共享文件夹 最后还是把虚拟机的安装过程放出来（可做参考） 2019/6/21：很久没写博客了，水一下。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/持续集成/"}]},{"title":"空虚【百度词条】","slug":"空虚【百度词条】","date":"2019-05-07T03:50:01.000Z","updated":"2019-07-19T08:42:41.725Z","comments":true,"path":"2019/05/07/空虚【百度词条】/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/05/07/空虚【百度词条】/","excerpt":"","text":"空虚【百度词条】 产生 心理空虚是不思追求、无所事事或不愿事事造成的。因为不思追求，失去了人生的奋斗目标，就不会有奋斗的乐趣和成功的欢愉。因为无所事事或不愿事事，就会感到生活无聊、心灵空乏虚无，就会感到寂寞难忍。于是，为了摆脱这种心理上的饥饿，就有可能因寻求刺激而去抽烟、喝酒、赌博、甚至闹事，以此来排遣时间。个别的还会走上偷盗、奸淫等犯罪的道路。空虚通常发生在这样两种情景之中：一种是物质条件优越，无需为生活烦恼和忙碌，习惯并满足于享受，看不到也不愿看到人生的真实意义，没有也不想有积极的生活目的；另一种是心比天高，对人们通常向往的目标不屑追求，而自己向往的目标又无法达到而难以追求，结果是无所追求，心灵虚无空荡，精神无从着落。 空虚和慵懒 空虚与慵懒不同。慵懒是心理上的懒散，是惰性使然，慵懒虽然是诱发空虚的条件，是不思追求、无所事事或不愿事事的温床，但慵懒未必一定导致空虚，因为慵懒的人心理上也可能很“充实”——喜欢懒散生活、满足懒散现状，尽管这种“充实”是消极的，对常人来讲是难以理解的，但慵懒的人并不会感到心理空虚。当然，慵懒的人如果逐渐感到无聊、寂寞、万事不称心并向往通过消极的新鲜刺激来排遣此种心情，以消磨时光，则就会演变成空虚的人。 克服空虚 要对抗空虚就要看清空虚的本质就是不存在。这时如能转移注意力做些“实质”的活动，如逛街就认真挑选衣物、聚会时就专心与人谈话，都可有效驱除空虚感。至于常感到空虚的人，很可能是活得不踏实。有些人在生活中怀有不切实际的期望或目标，自己总是在生活中追寻些什么，而没有落实到现实生活本身，不免常有虚幻感。要挥别空虚感就要建立“务实不务虚”的生活态度，能“活在当下”的人，心中是不会有这么一个黑洞的。要做到： 对社会应有一种较为现实的认识； 磨炼意志，正确对待失误与挫折； 多读名人传记； 积极参与社会实践； 多参加有益的娱乐活动； 正确的自我认识。 2019/5/7：骚练说你这是空虚，我百度了一下什么是空虚。","categories":[{"name":"心情","slug":"心情","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/心情/"}]},{"title":"剑指offer--复杂链表的复制","slug":"复杂链表的复制","date":"2019-04-29T03:50:01.000Z","updated":"2019-07-19T08:42:18.117Z","comments":true,"path":"2019/04/29/复杂链表的复制/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/29/复杂链表的复制/","excerpt":"","text":"复杂链表的复制 题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead)&#123; if(pHead == null)&#123; return null; &#125; //终极第一步：将原链表中的每个元素进行复制，并且放在相应元素的后面待用，如链表为1，2，3，现在复制过后为 //1，1'，2，2',3,3' RandomListNode currentNode = pHead; while(currentNode != null)&#123; //先将需要复制的值创建出来，然后再插入应该插入的位置,同时原本位置发生改变的，我们要提前创建放在那里 //待用，比如这里的currentNode的next RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; //终极第二步：接下来就是将复制出来的那些节点的random指向正确的RandomListNode //首先让当前节点回到正确的头节点位置，咱们好重新来过 currentNode = pHead; while(currentNode != null)&#123; currentNode.next.random = currentNode.random == null ? null : currentNode.random.next; currentNode = currentNode.next.next; &#125; //终极第三步：最后将原来的链表与现在新生成的链表进行分离，且返回复制的链表头节点 //首先还是将currentNode回到最初的起点，记忆中你青涩的脸。2333...... currentNode = pHead; RandomListNode pCloneHead = currentNode.next; while(currentNode != null)&#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next == null ? null : cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125;&#125; 告诫自己：不管怎样，要努力保持清醒的头脑，明白现在的你需要干什么。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"漫游","slug":"漫游","date":"2019-04-29T03:50:01.000Z","updated":"2019-07-19T08:43:02.166Z","comments":true,"path":"2019/04/29/漫游/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/29/漫游/","excerpt":"","text":"漫游 题记：Talking to the moon ，放不下的理由，是不是会担心，变成一只野兽，Walking on the roof ，为心跳的节奏是不是会暂停，在世界的尽头。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高考后，就没有认认真真写过东西，最近思想像是出现了问题，正好静下心来写一写，看看自己都在思考一些什么。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己的思想实际有时候很有意思的。可笑，无助，佛系，坚决······，本无关联，甚至对立面的东西，不同的时候都能找到一点影子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天帮朋友的朋友装了系统，出于一点强迫症，给她将系统头像和系统名换成了她的微信头像和微信昵称，事后，人家说，很好用，你真细心。一时竟不知如何回答，想了一下才说了句，个人强迫症。没说实际自己挺粗心大意的，因为粗心，无所谓，曾经弄丢了一个人。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在想想，说不上后悔，但也说不上放得开。有时觉得自己就是一条洄游的三文鱼，像是一生只有一个目标，就算力竭而亡，也不负初心，但同时又只是一条鱼，他只有七秒的记忆。游着游着就忘记了，原来还有一条鱼和你一起在向最后的目标努力着。只是有一天，那条鱼已经承受不住这漫长的旅程，身死力竭。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写到这里，竟不知要继续回忆一些什么，思考一些什么。我这暗绿色的键盘颜色，一如此刻的心情，安静，淡然，不舍。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众味杂陈。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;窗外修远楼的墙体，大致是经历的日晒和风雨多了。原本那种灰色是有一丝明快的感觉，如今他却没有光泽，有些黯淡，又如今天的天气，云色阴沉。而反观一旁的外国语学院，却像是一位可爱和蔼的婆婆，虽年岁已高，没有艳丽容颜，却格外沉稳，静默。此刻的建筑倒是像活了，有了个性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而我什么时候能活，我给自己凿了一个墓，固执的将灵魂埋在了里面。生命是如此多彩，建筑都这么可爱，而你在倔强的思考着什么。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哦，这只是一个真实的梦而已。六点半了，该起床了······","categories":[{"name":"随记","slug":"随记","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/随记/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/随记/"}]},{"title":"剑指offer --二叉树中和为某一值的路径","slug":"二叉树中和为某一值的路径","date":"2019-04-28T03:50:01.000Z","updated":"2019-07-19T08:41:33.429Z","comments":true,"path":"2019/04/28/二叉树中和为某一值的路径/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/28/二叉树中和为某一值的路径/","excerpt":"","text":"二叉树中和为某一值的路径 题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*//***题目大意：就是说从根节点到某一个叶子节点这条路径上的左右值相加等于target，那么这条路径就可以满足条件从而加入都这个ArrayList里面*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null)&#123; return listAll; &#125; list.add(root.val); target -= root.val; //这里&amp;&amp;，是左右满足才满足，如果第一个不满足，后面的就不用看了 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123; listAll.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left,target); FindPath(root.right,target); //这里实际我不是很清楚，总感觉有点不对劲，但是也说不上来。这波题解看的我有点懵逼，回复里面说了，是移除 //最后一个元素，深度遍历完一条路径后要回退，但我不是很明白，希望以后能动这个为什么是这样 list.remove(list.size() - 1); return listAll; &#125;&#125; 收获：今天帮一个妹子装了系统，学会了一个单词，Apathy，冷漠的意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer--二叉搜索树的后序遍历序列","slug":"二叉搜索树的后序遍历序列","date":"2019-04-27T03:50:01.000Z","updated":"2019-07-19T08:41:57.275Z","comments":true,"path":"2019/04/27/二叉搜索树的后序遍历序列/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/27/二叉搜索树的后序遍历序列/","excerpt":"","text":"二叉搜索树的后序遍历序列 题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920212223242526272829303132/***做题之前需明白两点：*1.先序遍历：根左右-----中序遍历：左根右-----后序遍历：左右根2.所谓二叉搜索树，又叫二叉查找树，二叉排序树，其特点是，所有的右子树的值小于根的值，根的值小于右子树的值，每个子树又全部是满足二叉搜索树的特点的*/public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0)&#123; return false; &#125; if(sequence.length == 1)&#123; return true; &#125; return check(sequence, 0, sequence.length - 1); &#125; public boolean check(int[] sequence, int start, int end)&#123; //这里是递归结束的判断依据 if(start &gt;= end)&#123; return true; &#125; int i = start; while(sequence[i] &lt; sequence[end])&#123; i++; &#125; for(int j = i; j &lt; end; j++)&#123; if(sequence[j] &lt; sequence[end]) return false; &#125; return check(sequence, start, i - 1) || check(sequence,i, end - 1); &#125;&#125; 情感：是不是真的相信这世上有纯洁的友谊。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer--包含min函数的栈","slug":"包含min函数的栈","date":"2019-04-25T03:50:01.000Z","updated":"2019-07-19T08:39:57.436Z","comments":true,"path":"2019/04/25/包含min函数的栈/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/25/包含min函数的栈/","excerpt":"","text":"包含min函数的栈 题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Stack;/***利用两个栈，一个保存传入的数据，一个用来依次保存出现的数字中更小的数字，比如第一次传进来的是 2 ，第二次传进来的*是 1 ，这个时候我们将1继续放在最小数栈的的顶部，这样就能一直保证那个最小栈的栈顶一直放的是最小的那个数**/public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;(); Integer temp = null; public void push(int node) &#123; if(temp != null)&#123; if(temp &gt; node)&#123; temp = node; minStack.push(node); &#125; stack.push(node); &#125;else&#123; minStack.push(node); stack.push(node); temp = node; &#125; &#125; public void pop() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; &#125; public int top() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; return num; &#125; public int min() &#123; int minNum = minStack.pop(); minStack.push(minNum); return minNum; &#125;&#125; 不是自己：明天是个好日子，3月21。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer--栈的压入，弹出序列","slug":"栈的压入，弹出序列","date":"2019-04-25T03:50:01.000Z","updated":"2019-07-19T08:45:21.661Z","comments":true,"path":"2019/04/25/栈的压入，弹出序列/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/25/栈的压入，弹出序列/","excerpt":"","text":"栈的压入，弹出序列 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Stack;/***此处的思路借助一个辅助的栈用来模拟压栈的过程，没次压入一个值，我们将这个值与弹出栈的值相比较看是否相等，如果想等就弹出，然后继续*判断之前压入的是否没弹出栈中的下一个元素相等，相等就弹出，重复进行，如果不想等，就压入下一个元素再继续比较，直到所有元素压栈完成*如果辅助栈中的元素不为空，则说明没有符合的弹出顺序。**/public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length == 0 || popA.length == 0)&#123; return false; &#125; //辅助栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); //用来记录弹出栈中的下标序号 int popIndex = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); //在这里判断辅助栈是否为空，且当前栈顶元素和弹栈的那个元素是否相等 while(!stack.empty() &amp;&amp; stack.peek() == popA[popIndex])&#123; stack.pop(); popIndex ++; &#125; &#125; return stack.empty(); &#125;&#125; 用代码麻痹自己：今天是你的生日，我却没资格送你生日的祝福，希望学习可以麻痹自己，希望你幸福，希望我能早日忘记昨天的不快。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer--顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2019-04-23T03:50:01.000Z","updated":"2019-07-19T08:44:18.202Z","comments":true,"path":"2019/04/23/顺时针打印矩阵/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/23/顺时针打印矩阵/","excerpt":"","text":"顺时针打印矩阵 题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(matrix == null)&#123; return result; &#125; int hight = matrix.length; int wide = matrix[0].length; //计算出要进行顺时钟打印的圈数 //这里为什么是取小的那个数来计算层数，这个我也说不上来，因为我只是一只小猫咪，23333。。。。 int count = (Math.min(hight,wide) -1)/2 + 1; for(int i = 0; i &lt; count; i++)&#123; //先让从左向右的值存进去； for(int k = i; k &lt; wide - i; k++)&#123; result.add(matrix[i][k]); &#125; //再存从由右上到右下的值； for(int j = i + 1; j &lt; hight - i; j++)&#123; result.add(matrix[j][wide-i-1]); &#125; //再存从右下到左下的值； //这里约束条件里hight-i-1 != i是为了不重复添加先从左到右添加的数， //如果都是那一行就没必要进行添加了 for(int k = wide - i - 2;k &gt;= i &amp;&amp; (hight-i-1 != i); k--)&#123; result.add(matrix[hight-i-1][k]); &#125; //最后存从左下到左上的值。 //这里约束条件里wide-i-1 != i是为了不重复添加先从左上到左下添加的数， //如果都是那一列就没必要进行添加了 for(int j = hight - i - 2;(j &gt; i) &amp;&amp; (wide-i-1 != i); j--)&#123; result.add(matrix[j][i]); &#125; &#125; return result; &#125;&#125; 对不起我没憋住：今天群里有位老哥的狗，会自己跑到洗手间便便，从不乱拉，这让我感觉很有意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer--二叉树的镜像","slug":"二叉树的镜像","date":"2019-04-22T03:50:01.000Z","updated":"2019-07-19T08:41:03.005Z","comments":true,"path":"2019/04/22/二叉树的镜像/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/22/二叉树的镜像/","excerpt":"","text":"二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; TreeNode tmp = null; //当树不为空的时候我们将左子树和右子树交换 if(root != null)&#123; tmp = root.left; root.left = root.right; root.right = tmp; //当左子树不为空的时候，继续进行递归 if(root.left != null)&#123; Mirror(root.left); &#125; //当右子树不为空的时候，继续进行递归 if(root.right != null)&#123; Mirror(root.right); &#125; &#125; &#125;&#125; 水水更健康：今天听说B站的源码被上传到github上了，本人在此声明：从未clone，下载或者以任何途径获得bilibili公司的任何非正常途径公开的代码。也没有参与，传播，任何bilibili的负面信息，且不认识看源码的兄弟。特此声明！划清界限","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"剑指offer-树的子结构","slug":"树的子结构","date":"2019-04-21T03:50:01.000Z","updated":"2019-07-19T08:43:58.864Z","comments":true,"path":"2019/04/21/树的子结构/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/21/树的子结构/","excerpt":"","text":"树的子结构 ###题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; //只有当两棵树都不为空才进行比较，否则返回false if(root1 != null &amp;&amp; root2 != null)&#123; //如果当前节点值相等，我们则继续进行从当前节点的比较 if(root1.val == root2.val)&#123; result = isHaveRootB(root1,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是左子树的子树 if(!result)&#123; result = HasSubtree(root1.left,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是右子树的子树 if(!result)&#123; result = HasSubtree(root1.right,root2); &#125; &#125; return result; &#125; public static boolean isHaveRootB(TreeNode node1,TreeNode node2)&#123; //如果子树已经遍历到最后，则前面都相等，此时说明是子树，返回true if(node2 == null)&#123; return true; &#125; //如果node1已经遍历完，说明没找到，此时返回false if(node1 == null)&#123; return false; &#125; //如果两个值不相等，说明不是的，直接返回false if(node1.val != node2.val)&#123; return false; &#125; //如果当前节点的值相等，则我们继续比较他们的左子树和右子树是不是相等 return isHaveRootB(node1.left,node2.left) &amp;&amp; isHaveRootB(node1.right,node2.right); &#125;&#125; 修炼：每一次做题都不会辜负自己。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]},{"title":"程序员修炼之路","slug":"程序员修炼之路","date":"2019-04-20T03:52:01.000Z","updated":"2019-07-19T09:26:49.736Z","comments":true,"path":"2019/04/20/程序员修炼之路/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/20/程序员修炼之路/","excerpt":"","text":"程序员修炼之路 https://github.com/Snailclimb/programmer-advancement 修炼：和优秀的人一起久了，也会变得优秀。","categories":[{"name":"资源","slug":"资源","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/资源/"}]},{"title":"计划清单","slug":"缘起","date":"2019-04-20T00:39:01.000Z","updated":"2019-07-19T08:45:00.858Z","comments":true,"path":"2019/04/20/缘起/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/20/缘起/","excerpt":"","text":"缘起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.一个人去泰山看一次日出；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.坚持早睡早起多运动；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.找到一份工作；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.刷150道题（leetcode 或者其他优先刷完剑指offer）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.看两本好书。 人生：只有平淡才能让自己的人生走的更远，只有多去看世界才能有与众不同的眼界。","categories":[{"name":"计划","slug":"计划","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/计划/"}],"tags":[{"name":"清单","slug":"清单","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/清单/"}]},{"title":"梦","slug":"梦？","date":"2019-04-16T04:43:01.000Z","updated":"2019-07-19T08:43:16.025Z","comments":true,"path":"2019/04/16/梦？/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/16/梦？/","excerpt":"","text":"昨日 一梦惊醒睡中人，我是真睡是假睡？","categories":[{"name":"心情","slug":"心情","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/心情/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/随记/"}]},{"title":"剑指offer--从上往下打印二叉树","slug":"从上往下打印二叉树","date":"2019-04-02T03:50:01.000Z","updated":"2019-07-19T08:41:14.662Z","comments":true,"path":"2019/04/02/从上往下打印二叉树/","link":"","permalink":"https://hick-salmon.github.io/Hick-Salmon/2019/04/02/从上往下打印二叉树/","excerpt":"","text":"从上往下打印二叉树 题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*//***利用ArrayList来模拟一个队列*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;(); if(root == null)&#123; return result; &#125; queue.add(root); while(queue.size() != 0)&#123; //ArrayList中的remove方法如果参数是int类型的，那么则会在移除该数值位置的那个值， //并且返回值是移除的这个值如果不清楚，可以参照图片中的顺序 TreeNode temp = queue.remove(0); if(temp.left != null)&#123; queue.add(temp.left); &#125; if(temp.right != null)&#123; queue.add(temp.right); &#125; result.add(temp.val); &#125; return result; &#125;&#125; 感悟：今天没什么写的，也许是最好的记录。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hick-salmon.github.io/Hick-Salmon/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hick-salmon.github.io/Hick-Salmon/tags/剑指offer/"}]}]}