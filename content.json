{"meta":{"title":"RuoShuiSanQian","subtitle":null,"description":null,"author":"HickSalmon","url":"https://hicksalmon.gitee.io","root":"/"},"pages":[{"title":"书单","date":"2019-04-16T03:08:20.829Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"books/index.html","permalink":"https://hicksalmon.gitee.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-16T03:08:20.833Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"https://hicksalmon.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-16T03:08:20.837Z","updated":"2019-03-28T01:36:53.000Z","comments":true,"path":"links/index.html","permalink":"https://hicksalmon.gitee.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-16T03:08:20.844Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"repository/index.html","permalink":"https://hicksalmon.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-16T03:08:20.848Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"https://hicksalmon.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-16T04:10:26.920Z","updated":"2019-04-16T04:10:26.920Z","comments":false,"path":"about/index.html","permalink":"https://hicksalmon.gitee.io/about/index.html","excerpt":"","text":"希望 奋斗 坚持 戒焦 戒躁 胸襟 知足 舍得 分享"},{"title":"404 Not Found：该页无法显示","date":"2019-04-16T03:08:20.808Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"/404.html","permalink":"https://hicksalmon.gitee.io//404.html","excerpt":"","text":""}],"posts":[{"title":"剑指offer 栈的压入，弹出序列","slug":"栈的压入，弹出序列","date":"2019-04-25T13:45:25.596Z","updated":"2019-04-25T13:45:25.747Z","comments":true,"path":"2019/04/25/栈的压入，弹出序列/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/25/栈的压入，弹出序列/","excerpt":"","text":"栈的压入，弹出序列 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Stack;/***此处的思路借助一个辅助的栈用来模拟压栈的过程，没次压入一个值，我们将这个值与弹出栈的值相比较看是否相等，如果想等就弹出，然后继续*判断之前压入的是否没弹出栈中的下一个元素相等，相等就弹出，重复进行，如果不想等，就压入下一个元素再继续比较，直到所有元素压栈完成*如果辅助栈中的元素不为空，则说明没有符合的弹出顺序。**/public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length == 0 || popA.length == 0)&#123; return false; &#125; //辅助栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); //用来记录弹出栈中的下标序号 int popIndex = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); //在这里判断辅助栈是否为空，且当前栈顶元素和弹栈的那个元素是否相等 while(!stack.empty() &amp;&amp; stack.peek() == popA[popIndex])&#123; stack.pop(); popIndex ++; &#125; &#125; return stack.empty(); &#125;&#125; 用代码麻痹自己：今天是你的生日，我却没资格送你生日的祝福，希望学习可以麻痹自己，希望你幸福，希望我能早日忘记昨天的不快。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 包含min函数的栈","slug":"包含min函数的栈","date":"2019-04-24T13:02:06.118Z","updated":"2019-04-24T13:02:06.224Z","comments":true,"path":"2019/04/24/包含min函数的栈/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/24/包含min函数的栈/","excerpt":"","text":"包含min函数的栈 题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Stack;/***利用两个栈，一个保存传入的数据，一个用来依次保存出现的数字中更小的数字，比如第一次传进来的是 2 ，第二次传进来的*是 1 ，这个时候我们将1继续放在最小数栈的的顶部，这样就能一直保证那个最小栈的栈顶一直放的是最小的那个数**/public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;(); Integer temp = null; public void push(int node) &#123; if(temp != null)&#123; if(temp &gt; node)&#123; temp = node; minStack.push(node); &#125; stack.push(node); &#125;else&#123; minStack.push(node); stack.push(node); temp = node; &#125; &#125; public void pop() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; &#125; public int top() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; return num; &#125; public int min() &#123; int minNum = minStack.pop(); minStack.push(minNum); return minNum; &#125;&#125; 不是自己：明天是个好日子，3月21。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2019-04-23T14:00:50.491Z","updated":"2019-04-23T14:00:50.629Z","comments":true,"path":"2019/04/23/顺时针打印矩阵/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/23/顺时针打印矩阵/","excerpt":"","text":"顺时针打印矩阵 题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(matrix == null)&#123; return result; &#125; int hight = matrix.length; int wide = matrix[0].length; //计算出要进行顺时钟打印的圈数 //这里为什么是取小的那个数来计算层数，这个我也说不上来，因为我只是一只小猫咪，23333。。。。 int count = (Math.min(hight,wide) -1)/2 + 1; for(int i = 0; i &lt; count; i++)&#123; //先让从左向右的值存进去； for(int k = i; k &lt; wide - i; k++)&#123; result.add(matrix[i][k]); &#125; //再存从由右上到右下的值； for(int j = i + 1; j &lt; hight - i; j++)&#123; result.add(matrix[j][wide-i-1]); &#125; //再存从右下到左下的值； //这里约束条件里hight-i-1 != i是为了不重复添加先从左到右添加的数， //如果都是那一行就没必要进行添加了 for(int k = wide - i - 2;k &gt;= i &amp;&amp; (hight-i-1 != i); k--)&#123; result.add(matrix[hight-i-1][k]); &#125; //最后存从左下到左上的值。 //这里约束条件里wide-i-1 != i是为了不重复添加先从左上到左下添加的数， //如果都是那一列就没必要进行添加了 for(int j = hight - i - 2;(j &gt; i) &amp;&amp; (wide-i-1 != i); j--)&#123; result.add(matrix[j][i]); &#125; &#125; return result; &#125;&#125; 对不起我没憋住：今天群里有位老哥的狗，会自己跑到洗手间便便，从不乱拉，这让我感觉很有意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 二叉树的镜像","slug":"二叉树的镜像","date":"2019-04-22T13:10:40.218Z","updated":"2019-04-22T13:10:32.620Z","comments":true,"path":"2019/04/22/二叉树的镜像/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/22/二叉树的镜像/","excerpt":"","text":"二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; TreeNode tmp = null; //当树不为空的时候我们将左子树和右子树交换 if(root != null)&#123; tmp = root.left; root.left = root.right; root.right = tmp; //当左子树不为空的时候，继续进行递归 if(root.left != null)&#123; Mirror(root.left); &#125; //当右子树不为空的时候，继续进行递归 if(root.right != null)&#123; Mirror(root.right); &#125; &#125; &#125;&#125; 水水更健康：今天听说B站的源码被上传到github上了，本人在此声明：从未clone，下载或者以任何途径获得bilibili公司的任何非正常途径公开的代码。也没有参与，传播，任何bilibili的负面信息，且不认识看源码的兄弟。特此声明！划清界限","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 树的子结构","slug":"树的子结构","date":"2019-04-21T14:05:37.421Z","updated":"2019-04-21T14:05:37.591Z","comments":true,"path":"2019/04/21/树的子结构/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/21/树的子结构/","excerpt":"","text":"树的子结构 ###题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; //只有当两棵树都不为空才进行比较，否则返回false if(root1 != null &amp;&amp; root2 != null)&#123; //如果当前节点值相等，我们则继续进行从当前节点的比较 if(root1.val == root2.val)&#123; result = isHaveRootB(root1,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是左子树的子树 if(!result)&#123; result = HasSubtree(root1.left,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是右子树的子树 if(!result)&#123; result = HasSubtree(root1.right,root2); &#125; &#125; return result; &#125; public static boolean isHaveRootB(TreeNode node1,TreeNode node2)&#123; //如果子树已经遍历到最后，则前面都相等，此时说明是子树，返回true if(node2 == null)&#123; return true; &#125; //如果node1已经遍历完，说明没找到，此时返回false if(node1 == null)&#123; return false; &#125; //如果两个值不相等，说明不是的，直接返回false if(node1.val != node2.val)&#123; return false; &#125; //如果当前节点的值相等，则我们继续比较他们的左子树和右子树是不是相等 return isHaveRootB(node1.left,node2.left) &amp;&amp; isHaveRootB(node1.right,node2.right); &#125;&#125; 修炼：每一次做题都不会辜负自己。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"程序员修炼之路","slug":"程序员修炼之路","date":"2019-04-20T03:58:27.864Z","updated":"2019-04-20T03:58:28.015Z","comments":true,"path":"2019/04/20/程序员修炼之路/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/20/程序员修炼之路/","excerpt":"","text":"程序员修炼之路 https://github.com/Snailclimb/programmer-advancement 修炼：和优秀的人一起久了，也会变得优秀。","categories":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/tags/资源/"}]},{"title":"计划清单","slug":"缘起","date":"2019-04-17T00:40:29.763Z","updated":"2019-04-20T13:40:04.298Z","comments":true,"path":"2019/04/17/缘起/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/17/缘起/","excerpt":"","text":"缘起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.一个人去泰山看一次日出；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.坚持早睡早起多运动；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.找到一份工作；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.刷150道题（leetcode 或者其他优先刷完剑指offer）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.看两本好书。 人生：只有平淡才能让自己的人生走的更远，只有多去看世界才能有与众不同的眼界。","categories":[{"name":"计划","slug":"计划","permalink":"https://hicksalmon.gitee.io/categories/计划/"}],"tags":[{"name":"清单","slug":"清单","permalink":"https://hicksalmon.gitee.io/tags/清单/"}]},{"title":"梦","slug":"梦？","date":"2019-04-16T02:56:06.319Z","updated":"2019-04-16T04:44:15.077Z","comments":true,"path":"2019/04/16/梦？/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/16/梦？/","excerpt":"","text":"昨日 一梦惊醒睡中人，我是真睡是假睡？","categories":[{"name":"心情","slug":"心情","permalink":"https://hicksalmon.gitee.io/categories/心情/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hicksalmon.gitee.io/tags/随记/"}]}]}