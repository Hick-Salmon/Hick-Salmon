{"meta":{"title":"RuoShuiSanQian","subtitle":null,"description":null,"author":"HickSalmon","url":"https://hicksalmon.gitee.io","root":"/"},"pages":[{"title":"友情链接","date":"2019-04-16T03:08:20.837Z","updated":"2019-03-28T01:36:53.000Z","comments":true,"path":"links/index.html","permalink":"https://hicksalmon.gitee.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-16T03:08:20.833Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"https://hicksalmon.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-04-16T03:08:20.808Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"/404.html","permalink":"https://hicksalmon.gitee.io//404.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-16T03:08:20.848Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"https://hicksalmon.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-04-16T03:08:20.829Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"books/index.html","permalink":"https://hicksalmon.gitee.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-16T03:08:20.844Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"repository/index.html","permalink":"https://hicksalmon.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-22T14:13:21.762Z","updated":"2019-04-16T04:10:26.920Z","comments":false,"path":"about/index.html","permalink":"https://hicksalmon.gitee.io/about/index.html","excerpt":"","text":"希望 奋斗 坚持 戒焦 戒躁 胸襟 知足 舍得 分享"}],"posts":[{"title":"Flutter初体验踩坑记录","slug":"初体验踩坑记录","date":"2019-07-07T03:50:01.000Z","updated":"2019-07-07T14:44:25.375Z","comments":true,"path":"2019/07/07/初体验踩坑记录/","link":"","permalink":"https://hicksalmon.gitee.io/2019/07/07/初体验踩坑记录/","excerpt":"","text":"Flutter初体验踩坑记录 由于Android Studio 实在过于慢了，我们在学习 Flutter 的时候，可以换用 VS Code 进行开发。 而采用 VS Code 开发时，启动我们的虚拟机，我们可以自己写一个 windows 的批处理文件来启动虚拟机。之前我们安装过虚拟机，我们只需要在 AS 中查看 AVD Manager 中的虚拟机名称记住，接下来写一个 .bat 的脚本文件，在桌面建立一个任意名字的 xxx.bat 文件，找到 emulator.exe 的文件路径，在里面添加简单的脚本，如我的如下： 1E:\\AndroidSDK\\emulator\\emulator.exe -netdelay none -netspeed full -avd YaErYo 前面是 emulator.exe 的文件路径，-netdelay none 是设置网络延迟为 0 ，-netspeed full 是设置网络速度为全速，-avd YaErYo 是之前在 Android Studio 中下载的虚拟机的名字，不知道可以打开 AS 进行查看，这里注意的是如果虚拟机的名字有空格，我们需要将空格换成下划线，否则会报错。我这里的名字叫 YaErYo 没有下划线就不用管。 当我们使用 VS Code 进行开发的时候，首先使用管理员权限运行我们之前建立的的 xxx.bat 脚本启动虚拟机，然后在 VS Code 中使用 Ctrl + ~ 调起命令行工具，使用 flutter run 命令进行启动 flutter 程序，这样的目的是方便我们，在后续的过程中，使用快捷键 o 快速切换 IOS 界面 和 Android 界面视图；使用快捷键 p 显示虚拟机视图的网格，方便我们调试； 使用快捷键 r 实现热更新。 2019/7/7：家是温暖的港湾，需要的是温度，不是压力，善待最亲近的人。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://hicksalmon.gitee.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://hicksalmon.gitee.io/tags/Flutter/"}]},{"title":"日志","slug":"日志","date":"2019-07-06T14:45:40.034Z","updated":"2019-07-06T14:49:50.606Z","comments":true,"path":"2019/07/06/日志/","link":"","permalink":"https://hicksalmon.gitee.io/2019/07/06/日志/","excerpt":"","text":"日志JCL组件结构图适配器模式 为了解决 jcl 的不足出现了 slf4j ， jcl 通过源码发现，他是采用的一个适配器模式，动态的去决定使用哪种日志，而 slf4j 不一样，他是采用的一种静态桥接方式，是用什么日志，就需要自己添加相应的桥接。对于slf4j的简介如下： 具体的桥接见下图: 这里注意只有老版的 spring 是用的 jcl ，新版的 spring 并不是采用 jcl 实现的。 出现这种问题，解决方案有两种1）直接将app中的日志桥接到log4j，即加一个slf4j-log4j12 的桥接器；2）是通过一个替换器（jcl-over-slf4j）将jcl替换掉，来用 slf4f 的，即使用 log4j2 . 同理其他的日志在slf4j中也可以替换成功，替换方法如下： 这个时候要注意一点就是不要，同时使用一种日志实现的适配和桥接，不然就会进入一个死循环，运行就会报一个 StackOverflowError ，堆栈溢出的错误。如下图： 最后放一张简单的 log4j2.xml 的配置文件。 2019/7/6：生活的主题就是，面对复杂，保持欢喜。","categories":[{"name":"日志","slug":"日志","permalink":"https://hicksalmon.gitee.io/categories/日志/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://hicksalmon.gitee.io/tags/日志/"}]},{"title":"3. jenkins学习--持续集成01","slug":"3. Jenkins学习--持续集成01","date":"2019-07-02T13:46:32.897Z","updated":"2019-07-02T14:00:10.828Z","comments":true,"path":"2019/07/02/3. Jenkins学习--持续集成01/","link":"","permalink":"https://hicksalmon.gitee.io/2019/07/02/3. Jenkins学习--持续集成01/","excerpt":"","text":"3. Jenkins学习–持续集成01 1.jenkins安装jenkins安装方式很多，在这里我采用的是将 jenkins 的 war 放入 tomcat 中运行来安装的 jenkins 。官网下载 jenkins war 包。 https://jenkins.io/zh/download/利用Xftp 6 上传 war 至 tomcat 的 webapp 目录，运行 tomcat （./bin/startup.sh）根据提示进行后续安装，选择插件安装的时候，选择默认的插件进行安装。2.jenkins JDK 配置JDK需要注意在服务器中需要配置环境变量， /etc/profile 中进行配置3.jenkins Maven 配置maven需要注意在服务器中需要配置环境变量， /etc/profile 中进行配置 4.jenkins git 配置 5.项目建立与码云打通如果是私有项目需要添加代码托管平台的账号和密码，才能拉取代码。6.使用 执行shell 实现持续集成 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; #!/bin/bash&gt; source /etc/profile&gt; tomcat_path=/usr/tomcat/apache-tomcat-8.5.38/webapps&gt; #war包路径 及 名称&gt; war_path=/root/.jenkins/workspace/conformity/target/firstone.war&gt; war_name=conformity.war&gt; war_file=$&#123;war_path&#125;$&#123;war_name&#125;&gt; #从git中下载的源码路径&gt; #$&#123;JENKINS_HOME&#125; 为全局变量 请事先查看 有没有声明没有在 在/etc/profile中声明&gt; #export JENKINS_HOME=/opt/run_/tomcat/tomcat8-7979/webapps/jenkins&gt; source_path=$&#123;JENKINS_HOME&#125;/workspace/conformity&gt; #su root&gt; #xtj1008611&gt; echo \"切换到root用户成功\"&gt; cd root/.jenkins/jobs/conformity&gt; #日志所在路径&gt; log_file=$&#123;JENKINS_HOME&#125;\"/build_log.log\"&gt; echo \"一个大西瓜\" $&#123;log_file&#125;&gt; #定义一个函数 用来写入log文件&gt; writeLogFun()&#123;&gt; if [ ! -e $log_file ]&gt; then&gt; echo \"文件不存在 新建一个\"&gt; touch $&#123;log_file&#125;&gt; fi&gt; nowtime=`date +%Y%m%d%H%M%S`&gt; echo $nowtime$1 &gt;&gt; $log_file&gt; &#125;&gt; writeLogFun \"开始执行 mvn install命令当前路径$(pwd)\"&gt; #mvn install&gt; mvn package&gt; echo $&#123;war_file&#125;&gt; su root&gt; xtj100861&gt; mv $&#123;war_path&#125; $&#123;tomcat_path&#125;&gt; echo \"两个大西瓜\" $&#123;tomcat_path&#125;&gt; sleep 1s&gt; writeLogFun \"tomcat 进行重启\"&gt; cd $&#123;tomcat_path&#125;&gt; ll&gt; cd ..&gt; ./bin/startup.sh&gt; echo [-e $&#123;war_file&#125;]&gt; echo \"好像是成功了\"&gt; 打包的时候可能出现找不到 xml 文件的情况。 org.springframework.beans.factory.BeanDefinitionStoreException: Could not resolve bean definition resource pattern [classpath:spring/applicationContext-*.xml]; nested exception is java.io.FileNotFoundException: class path resource [spring/] cannot be resolved to URL because it does not exist 此时是因为默认 maven 不扫描 xml文件，我们需要在 pom 文件中申明 123456789101112&gt; &lt;build&gt; &gt; &lt;resources&gt;&gt; &lt;resource&gt;&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&gt; &lt;includes&gt;&gt; &lt;include&gt;**/*.properties&lt;/include&gt;&gt; &lt;include&gt;**/*.xml&lt;/include&gt;&gt; &lt;/includes&gt;&gt; &lt;filtering&gt;false&lt;/filtering&gt;&gt; &lt;/resources&gt;&gt; &lt;/build&gt;&gt; shell 脚本能力还不够，需要加强，这里将之前的项目简单的上传打包，并发布成功了。具体的 shell 还得具体对待。 2019/7/2：今天骚练在我家，明天他就回家了，我继续上班，不久的将来他去福建农林大学读研究生。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hicksalmon.gitee.io/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hicksalmon.gitee.io/tags/持续集成/"}]},{"title":"2.jenkins学习--虚拟机坑点2","slug":"2.Jenkins学习--虚拟机坑点2","date":"2019-06-22T06:50:16.529Z","updated":"2019-06-22T06:49:45.013Z","comments":true,"path":"2019/06/22/2.Jenkins学习--虚拟机坑点2/","link":"","permalink":"https://hicksalmon.gitee.io/2019/06/22/2.Jenkins学习--虚拟机坑点2/","excerpt":"","text":"2. Jenkins学习–虚拟机坑点2 少了一些图形库文件引发一些故事 我在 VMware Workstation 装的是Ubuntu 16.04 server iso ，以至于差一些支持图形界面的库，当我想要安装jenkins时，出现了今天的第一个坑点，出现关于 AWT 的错误：java.lang.UnsatisfiedLinkError: /mnt/jdk1.8/jre/lib/amd64/libawt_xawt.so: libXtst.so.6: cannot open shared object file: No such file or directory百度了一下，需要安装，命令如下：apt-get install libxrender-devapt-get install libxtst-dev 至此出现第二个关于虚拟机客户端的坑点（动态IP让我虚拟机不能上网了）。首先了解了一下 VMWare Workstation中几种联网方式：(1) Bridged: Connected directly to the physical network，使用桥接网卡（VMnet0虚拟网卡），表示当前虚拟机与主机（指运行VMware Workstation软件的计算机）在同一个网络中;(2) NAT: Used to share the host’s IP address，使用NAT网卡（VMnet8虚拟网卡），表示虚拟机通过主机单向访问主机及主机之外的网络，主机之外的网络中的计算机，不能访问该虚拟机;(3) Host-only： A private network shared with the host，只使用本地网络（VMnet1虚拟网卡），表示虚拟机只能访问主机及所有使用VMnet1虚拟网卡的虚拟机。主机之外的网络中的计算机不能访问该虚拟机，也不能被该虚拟机所访问；(4) Custom: Specific virtual network，没有网络连接，表明该虚拟机与主机没有网络连接。# 而我前一天使用的时桥接模式,我的笔记本使用的又是 wifi ，路由器现在基本都是动态 IP ，基于此，前一天虚拟机客户端还能上网，今天不能上网了，可能就是虚拟机中默认使用了之前的 IP ，现在主机 IP 改变，他却没变，使得虚拟机不能上网了。于是在这里我就将联网模式改成 NAT 模式了，然后重启客户端就可以让虚拟机上网了。重启很重要，最后通过 ifconfig 查看分配给客户端的 IP ，使用Xshell 就可以上网了。 2019/6/22：打开窗户让孤单透气，这一间屋子如此密闭，欢呼声仍飘在空气里，想空无一人的华丽。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hicksalmon.gitee.io/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hicksalmon.gitee.io/tags/持续集成/"}]},{"title":"1. jenkins学习--虚拟机坑点1","slug":"1.Jenkins学习--虚拟机坑点","date":"2019-06-21T14:08:09.791Z","updated":"2019-06-22T06:45:50.745Z","comments":true,"path":"2019/06/21/1.Jenkins学习--虚拟机坑点/","link":"","permalink":"https://hicksalmon.gitee.io/2019/06/21/1.Jenkins学习--虚拟机坑点/","excerpt":"","text":"1.Jenkins学习–虚拟机坑点1 买不起服务器就虚拟机来凑 VMware Workstation 作为一种在桌面可以运行多种操作系统的虚拟计算机软件，首当其冲的要第一个搞定。这个的安装，我是之前安装好的没有什么记忆了，在此不做什么坑点的记录了。 Ubuntu 系统的安装坑点 从官网下载好了Ubuntu 16.04 server iso 镜像，server 镜像地址见 https://ubuntu.com/download/alternative-downloads ，可自由选择相关的版本； 在 VM 中进行安装，参照教程（具体操作我已经截图放在总结之后，即最后的截图），源地址： https://www.cnblogs.com/Alier/p/6337151.html 不过这里我下载的是 server ，在这里遇到几个坑点。 （1）. 安装过程中语言需要选择英文，否则在后续的安装过程中会出现语言包的问题，或者在安装完成时会出现乱码的问题。这个就很烦，应该有办法解决但是我没深入了解； （2）.默认下载的ubuntu系统镜像源是 us 。所以会出现下载其他东西时很慢的现象，这个可以通过换镜像源的方式进行改进。 镜像更改如下操作： #利用vim修改镜像源配置vim /etc/apt/sources.list#替换为阿里的镜像源deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse#更新sudo apt-get update 3.我们平时可能用Xshell或者其他的远程连接工具更多，所以我们在这里安装好虚拟机之后一样用远程连接工具进行连接，这个时候往往会出现另一个比较坑的就是，发现用工具连不上，我在这里就出现了，原因是我的ubuntu没有支持 SSH ，所以在这里需要安装 SSH（安装过程不赘述）；4.最后想要记录的是关于系统与虚拟机中如何实现文件共享的，我们可以在系统的某个盘中建立一个共享文件夹，然后在虚拟机中设置为共享文件夹。详情见下图：系统的共享文件夹虚拟机软件设置命令行查看到的共享文件夹 最后还是把虚拟机的安装过程放出来（可做参考） 2019/6/21：很久没写博客了，水一下。","categories":[{"name":"CD-CI","slug":"CD-CI","permalink":"https://hicksalmon.gitee.io/categories/CD-CI/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://hicksalmon.gitee.io/tags/持续集成/"}]},{"title":"空虚【百度词条】","slug":"空虚【百度词条】","date":"2019-05-07T14:18:43.518Z","updated":"2019-05-07T14:18:43.634Z","comments":true,"path":"2019/05/07/空虚【百度词条】/","link":"","permalink":"https://hicksalmon.gitee.io/2019/05/07/空虚【百度词条】/","excerpt":"","text":"空虚【百度词条】 产生 心理空虚是不思追求、无所事事或不愿事事造成的。因为不思追求，失去了人生的奋斗目标，就不会有奋斗的乐趣和成功的欢愉。因为无所事事或不愿事事，就会感到生活无聊、心灵空乏虚无，就会感到寂寞难忍。于是，为了摆脱这种心理上的饥饿，就有可能因寻求刺激而去抽烟、喝酒、赌博、甚至闹事，以此来排遣时间。个别的还会走上偷盗、奸淫等犯罪的道路。空虚通常发生在这样两种情景之中：一种是物质条件优越，无需为生活烦恼和忙碌，习惯并满足于享受，看不到也不愿看到人生的真实意义，没有也不想有积极的生活目的；另一种是心比天高，对人们通常向往的目标不屑追求，而自己向往的目标又无法达到而难以追求，结果是无所追求，心灵虚无空荡，精神无从着落。 空虚和慵懒 空虚与慵懒不同。慵懒是心理上的懒散，是惰性使然，慵懒虽然是诱发空虚的条件，是不思追求、无所事事或不愿事事的温床，但慵懒未必一定导致空虚，因为慵懒的人心理上也可能很“充实”——喜欢懒散生活、满足懒散现状，尽管这种“充实”是消极的，对常人来讲是难以理解的，但慵懒的人并不会感到心理空虚。当然，慵懒的人如果逐渐感到无聊、寂寞、万事不称心并向往通过消极的新鲜刺激来排遣此种心情，以消磨时光，则就会演变成空虚的人。 克服空虚 要对抗空虚就要看清空虚的本质就是不存在。这时如能转移注意力做些“实质”的活动，如逛街就认真挑选衣物、聚会时就专心与人谈话，都可有效驱除空虚感。至于常感到空虚的人，很可能是活得不踏实。有些人在生活中怀有不切实际的期望或目标，自己总是在生活中追寻些什么，而没有落实到现实生活本身，不免常有虚幻感。要挥别空虚感就要建立“务实不务虚”的生活态度，能“活在当下”的人，心中是不会有这么一个黑洞的。要做到： 对社会应有一种较为现实的认识； 磨炼意志，正确对待失误与挫折； 多读名人传记； 积极参与社会实践； 多参加有益的娱乐活动； 正确的自我认识。 2019/5/7：骚练说你这是空虚，我百度了一下什么是空虚。","categories":[{"name":"心情","slug":"心情","permalink":"https://hicksalmon.gitee.io/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://hicksalmon.gitee.io/tags/心情/"}]},{"title":"剑指offer 复杂链表的复制","slug":"复杂链表的复制","date":"2019-04-29T12:42:43.505Z","updated":"2019-04-29T12:42:43.594Z","comments":true,"path":"2019/04/29/复杂链表的复制/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/29/复杂链表的复制/","excerpt":"","text":"复杂链表的复制 题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead)&#123; if(pHead == null)&#123; return null; &#125; //终极第一步：将原链表中的每个元素进行复制，并且放在相应元素的后面待用，如链表为1，2，3，现在复制过后为 //1，1'，2，2',3,3' RandomListNode currentNode = pHead; while(currentNode != null)&#123; //先将需要复制的值创建出来，然后再插入应该插入的位置,同时原本位置发生改变的，我们要提前创建放在那里 //待用，比如这里的currentNode的next RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; //终极第二步：接下来就是将复制出来的那些节点的random指向正确的RandomListNode //首先让当前节点回到正确的头节点位置，咱们好重新来过 currentNode = pHead; while(currentNode != null)&#123; currentNode.next.random = currentNode.random == null ? null : currentNode.random.next; currentNode = currentNode.next.next; &#125; //终极第三步：最后将原来的链表与现在新生成的链表进行分离，且返回复制的链表头节点 //首先还是将currentNode回到最初的起点，记忆中你青涩的脸。2333...... currentNode = pHead; RandomListNode pCloneHead = currentNode.next; while(currentNode != null)&#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next == null ? null : cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125;&#125; 告诫自己：不管怎样，要努力保持清醒的头脑，明白现在的你需要干什么。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"漫游","slug":"漫游","date":"2019-04-29T03:16:46.196Z","updated":"2019-04-29T03:17:44.184Z","comments":true,"path":"2019/04/29/漫游/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/29/漫游/","excerpt":"","text":"漫游 题记：Talking to the moon ，放不下的理由，是不是会担心，变成一只野兽，Walking on the roof ，为心跳的节奏是不是会暂停，在世界的尽头。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高考后，就没有认认真真写过东西，最近思想像是出现了问题，正好静下心来写一写，看看自己都在思考一些什么。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己的思想实际有时候很有意思的。可笑，无助，佛系，坚决······，本无关联，甚至对立面的东西，不同的时候都能找到一点影子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天帮朋友的朋友装了系统，出于一点强迫症，给她将系统头像和系统名换成了她的微信头像和微信昵称，事后，人家说，很好用，你真细心。一时竟不知如何回答，想了一下才说了句，个人强迫症。没说实际自己挺粗心大意的，因为粗心，无所谓，曾经弄丢了一个人。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在想想，说不上后悔，但也说不上放得开。有时觉得自己就是一条洄游的三文鱼，像是一生只有一个目标，就算力竭而亡，也不负初心，但同时又只是一条鱼，他只有七秒的记忆。游着游着就忘记了，原来还有一条鱼和你一起在向最后的目标努力着。只是有一天，那条鱼已经承受不住这漫长的旅程，身死力竭。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写到这里，竟不知要继续回忆一些什么，思考一些什么。我这暗绿色的键盘颜色，一如此刻的心情，安静，淡然，不舍。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众味杂陈。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;窗外修远楼的墙体，大致是经历的日晒和风雨多了。原本那种灰色是有一丝明快的感觉，如今他却没有光泽，有些黯淡，又如今天的天气，云色阴沉。而反观一旁的外国语学院，却像是一位可爱和蔼的婆婆，虽年岁已高，没有艳丽容颜，却格外沉稳，静默。此刻的建筑倒是像活了，有了个性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而我什么时候能活，我给自己凿了一个墓，固执的将灵魂埋在了里面。生命是如此多彩，建筑都这么可爱，而你在倔强的思考着什么。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哦，这只是一个真实的梦而已。六点半了，该起床了······","categories":[{"name":"随记","slug":"随记","permalink":"https://hicksalmon.gitee.io/categories/随记/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hicksalmon.gitee.io/tags/随记/"}]},{"title":"剑指offer  二叉树中和为某一值的路径","slug":"二叉树中和为某一值的路径","date":"2019-04-28T13:43:20.137Z","updated":"2019-04-28T13:43:20.238Z","comments":true,"path":"2019/04/28/二叉树中和为某一值的路径/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/28/二叉树中和为某一值的路径/","excerpt":"","text":"二叉树中和为某一值的路径 题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*//***题目大意：就是说从根节点到某一个叶子节点这条路径上的左右值相加等于target，那么这条路径就可以满足条件从而加入都这个ArrayList里面*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null)&#123; return listAll; &#125; list.add(root.val); target -= root.val; //这里&amp;&amp;，是左右满足才满足，如果第一个不满足，后面的就不用看了 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123; listAll.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left,target); FindPath(root.right,target); //这里实际我不是很清楚，总感觉有点不对劲，但是也说不上来。这波题解看的我有点懵逼，回复里面说了，是移除 //最后一个元素，深度遍历完一条路径后要回退，但我不是很明白，希望以后能动这个为什么是这样 list.remove(list.size() - 1); return listAll; &#125;&#125; 收获：今天帮一个妹子装了系统，学会了一个单词，Apathy，冷漠的意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 二叉搜索树的后序遍历序列","slug":"二叉搜索树的后序遍历序列","date":"2019-04-27T09:29:32.272Z","updated":"2019-04-27T09:29:32.349Z","comments":true,"path":"2019/04/27/二叉搜索树的后序遍历序列/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/27/二叉搜索树的后序遍历序列/","excerpt":"","text":"二叉搜索树的后序遍历序列 题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920212223242526272829303132/***做题之前需明白两点：*1.先序遍历：根左右-----中序遍历：左根右-----后序遍历：左右根2.所谓二叉搜索树，又叫二叉查找树，二叉排序树，其特点是，所有的右子树的值小于根的值，根的值小于右子树的值，每个子树又全部是满足二叉搜索树的特点的*/public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0)&#123; return false; &#125; if(sequence.length == 1)&#123; return true; &#125; return check(sequence, 0, sequence.length - 1); &#125; public boolean check(int[] sequence, int start, int end)&#123; //这里是递归结束的判断依据 if(start &gt;= end)&#123; return true; &#125; int i = start; while(sequence[i] &lt; sequence[end])&#123; i++; &#125; for(int j = i; j &lt; end; j++)&#123; if(sequence[j] &lt; sequence[end]) return false; &#125; return check(sequence, start, i - 1) || check(sequence,i, end - 1); &#125;&#125; 情感：是不是真的相信这世上有纯洁的友谊。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 从上往下打印二叉树","slug":"从上往下打印二叉树","date":"2019-04-26T12:26:17.613Z","updated":"2019-04-26T13:20:53.987Z","comments":true,"path":"2019/04/26/从上往下打印二叉树/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/26/从上往下打印二叉树/","excerpt":"","text":"从上往下打印二叉树 题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*//***利用ArrayList来模拟一个队列*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;(); if(root == null)&#123; return result; &#125; queue.add(root); while(queue.size() != 0)&#123; //ArrayList中的remove方法如果参数是int类型的，那么则会在移除该数值位置的那个值， //并且返回值是移除的这个值如果不清楚，可以参照图片中的顺序 TreeNode temp = queue.remove(0); if(temp.left != null)&#123; queue.add(temp.left); &#125; if(temp.right != null)&#123; queue.add(temp.right); &#125; result.add(temp.val); &#125; return result; &#125;&#125; 感悟：今天没什么写的，也许是最好的记录。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 栈的压入，弹出序列","slug":"栈的压入，弹出序列","date":"2019-04-25T13:45:25.596Z","updated":"2019-04-25T13:45:25.747Z","comments":true,"path":"2019/04/25/栈的压入，弹出序列/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/25/栈的压入，弹出序列/","excerpt":"","text":"栈的压入，弹出序列 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Stack;/***此处的思路借助一个辅助的栈用来模拟压栈的过程，没次压入一个值，我们将这个值与弹出栈的值相比较看是否相等，如果想等就弹出，然后继续*判断之前压入的是否没弹出栈中的下一个元素相等，相等就弹出，重复进行，如果不想等，就压入下一个元素再继续比较，直到所有元素压栈完成*如果辅助栈中的元素不为空，则说明没有符合的弹出顺序。**/public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length == 0 || popA.length == 0)&#123; return false; &#125; //辅助栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); //用来记录弹出栈中的下标序号 int popIndex = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); //在这里判断辅助栈是否为空，且当前栈顶元素和弹栈的那个元素是否相等 while(!stack.empty() &amp;&amp; stack.peek() == popA[popIndex])&#123; stack.pop(); popIndex ++; &#125; &#125; return stack.empty(); &#125;&#125; 用代码麻痹自己：今天是你的生日，我却没资格送你生日的祝福，希望学习可以麻痹自己，希望你幸福，希望我能早日忘记昨天的不快。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 包含min函数的栈","slug":"包含min函数的栈","date":"2019-04-24T13:02:06.118Z","updated":"2019-04-24T13:02:06.224Z","comments":true,"path":"2019/04/24/包含min函数的栈/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/24/包含min函数的栈/","excerpt":"","text":"包含min函数的栈 题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Stack;/***利用两个栈，一个保存传入的数据，一个用来依次保存出现的数字中更小的数字，比如第一次传进来的是 2 ，第二次传进来的*是 1 ，这个时候我们将1继续放在最小数栈的的顶部，这样就能一直保证那个最小栈的栈顶一直放的是最小的那个数**/public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;(); Integer temp = null; public void push(int node) &#123; if(temp != null)&#123; if(temp &gt; node)&#123; temp = node; minStack.push(node); &#125; stack.push(node); &#125;else&#123; minStack.push(node); stack.push(node); temp = node; &#125; &#125; public void pop() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; &#125; public int top() &#123; int num = stack.pop(); int numMin = minStack.pop(); if(num != numMin)&#123; minStack.push(numMin); &#125; return num; &#125; public int min() &#123; int minNum = minStack.pop(); minStack.push(minNum); return minNum; &#125;&#125; 不是自己：明天是个好日子，3月21。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2019-04-23T14:00:50.491Z","updated":"2019-04-23T14:00:50.629Z","comments":true,"path":"2019/04/23/顺时针打印矩阵/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/23/顺时针打印矩阵/","excerpt":"","text":"顺时针打印矩阵 题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(matrix == null)&#123; return result; &#125; int hight = matrix.length; int wide = matrix[0].length; //计算出要进行顺时钟打印的圈数 //这里为什么是取小的那个数来计算层数，这个我也说不上来，因为我只是一只小猫咪，23333。。。。 int count = (Math.min(hight,wide) -1)/2 + 1; for(int i = 0; i &lt; count; i++)&#123; //先让从左向右的值存进去； for(int k = i; k &lt; wide - i; k++)&#123; result.add(matrix[i][k]); &#125; //再存从由右上到右下的值； for(int j = i + 1; j &lt; hight - i; j++)&#123; result.add(matrix[j][wide-i-1]); &#125; //再存从右下到左下的值； //这里约束条件里hight-i-1 != i是为了不重复添加先从左到右添加的数， //如果都是那一行就没必要进行添加了 for(int k = wide - i - 2;k &gt;= i &amp;&amp; (hight-i-1 != i); k--)&#123; result.add(matrix[hight-i-1][k]); &#125; //最后存从左下到左上的值。 //这里约束条件里wide-i-1 != i是为了不重复添加先从左上到左下添加的数， //如果都是那一列就没必要进行添加了 for(int j = hight - i - 2;(j &gt; i) &amp;&amp; (wide-i-1 != i); j--)&#123; result.add(matrix[j][i]); &#125; &#125; return result; &#125;&#125; 对不起我没憋住：今天群里有位老哥的狗，会自己跑到洗手间便便，从不乱拉，这让我感觉很有意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 二叉树的镜像","slug":"二叉树的镜像","date":"2019-04-22T13:10:40.218Z","updated":"2019-04-22T13:10:32.620Z","comments":true,"path":"2019/04/22/二叉树的镜像/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/22/二叉树的镜像/","excerpt":"","text":"二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; TreeNode tmp = null; //当树不为空的时候我们将左子树和右子树交换 if(root != null)&#123; tmp = root.left; root.left = root.right; root.right = tmp; //当左子树不为空的时候，继续进行递归 if(root.left != null)&#123; Mirror(root.left); &#125; //当右子树不为空的时候，继续进行递归 if(root.right != null)&#123; Mirror(root.right); &#125; &#125; &#125;&#125; 水水更健康：今天听说B站的源码被上传到github上了，本人在此声明：从未clone，下载或者以任何途径获得bilibili公司的任何非正常途径公开的代码。也没有参与，传播，任何bilibili的负面信息，且不认识看源码的兄弟。特此声明！划清界限","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 树的子结构","slug":"树的子结构","date":"2019-04-21T14:05:37.421Z","updated":"2019-04-21T14:05:37.591Z","comments":true,"path":"2019/04/21/树的子结构/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/21/树的子结构/","excerpt":"","text":"树的子结构 ###题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; //只有当两棵树都不为空才进行比较，否则返回false if(root1 != null &amp;&amp; root2 != null)&#123; //如果当前节点值相等，我们则继续进行从当前节点的比较 if(root1.val == root2.val)&#123; result = isHaveRootB(root1,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是左子树的子树 if(!result)&#123; result = HasSubtree(root1.left,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是右子树的子树 if(!result)&#123; result = HasSubtree(root1.right,root2); &#125; &#125; return result; &#125; public static boolean isHaveRootB(TreeNode node1,TreeNode node2)&#123; //如果子树已经遍历到最后，则前面都相等，此时说明是子树，返回true if(node2 == null)&#123; return true; &#125; //如果node1已经遍历完，说明没找到，此时返回false if(node1 == null)&#123; return false; &#125; //如果两个值不相等，说明不是的，直接返回false if(node1.val != node2.val)&#123; return false; &#125; //如果当前节点的值相等，则我们继续比较他们的左子树和右子树是不是相等 return isHaveRootB(node1.left,node2.left) &amp;&amp; isHaveRootB(node1.right,node2.right); &#125;&#125; 修炼：每一次做题都不会辜负自己。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"程序员修炼之路","slug":"程序员修炼之路","date":"2019-04-20T03:58:27.864Z","updated":"2019-04-20T03:58:28.015Z","comments":true,"path":"2019/04/20/程序员修炼之路/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/20/程序员修炼之路/","excerpt":"","text":"程序员修炼之路 https://github.com/Snailclimb/programmer-advancement 修炼：和优秀的人一起久了，也会变得优秀。","categories":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/tags/资源/"}]},{"title":"计划清单","slug":"缘起","date":"2019-04-17T00:40:29.763Z","updated":"2019-04-20T13:40:04.298Z","comments":true,"path":"2019/04/17/缘起/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/17/缘起/","excerpt":"","text":"缘起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.一个人去泰山看一次日出；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.坚持早睡早起多运动；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.找到一份工作；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.刷150道题（leetcode 或者其他优先刷完剑指offer）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.看两本好书。 人生：只有平淡才能让自己的人生走的更远，只有多去看世界才能有与众不同的眼界。","categories":[{"name":"计划","slug":"计划","permalink":"https://hicksalmon.gitee.io/categories/计划/"}],"tags":[{"name":"清单","slug":"清单","permalink":"https://hicksalmon.gitee.io/tags/清单/"}]},{"title":"梦","slug":"梦？","date":"2019-04-16T02:56:06.319Z","updated":"2019-04-16T04:44:15.077Z","comments":true,"path":"2019/04/16/梦？/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/16/梦？/","excerpt":"","text":"昨日 一梦惊醒睡中人，我是真睡是假睡？","categories":[{"name":"心情","slug":"心情","permalink":"https://hicksalmon.gitee.io/categories/心情/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hicksalmon.gitee.io/tags/随记/"}]}]}