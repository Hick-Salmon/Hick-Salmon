{"meta":{"title":"RuoShuiSanQian","subtitle":null,"description":null,"author":"HickSalmon","url":"https://hicksalmon.gitee.io","root":"/"},"pages":[{"title":"书单","date":"2019-04-16T03:08:20.829Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"books/index.html","permalink":"https://hicksalmon.gitee.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-16T03:08:20.833Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"categories/index.html","permalink":"https://hicksalmon.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-16T03:08:20.837Z","updated":"2019-03-28T01:36:53.000Z","comments":true,"path":"links/index.html","permalink":"https://hicksalmon.gitee.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-16T03:08:20.844Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"repository/index.html","permalink":"https://hicksalmon.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-16T03:08:20.848Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"tags/index.html","permalink":"https://hicksalmon.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-16T04:10:26.920Z","updated":"2019-04-16T04:10:26.920Z","comments":false,"path":"about/index.html","permalink":"https://hicksalmon.gitee.io/about/index.html","excerpt":"","text":"希望 奋斗 坚持 戒焦 戒躁 胸襟 知足 舍得 分享"},{"title":"404 Not Found：该页无法显示","date":"2019-04-16T03:08:20.808Z","updated":"2019-03-28T01:36:53.000Z","comments":false,"path":"/404.html","permalink":"https://hicksalmon.gitee.io//404.html","excerpt":"","text":""}],"posts":[{"title":"剑指offer 顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2019-04-23T14:00:50.491Z","updated":"2019-04-23T14:00:50.629Z","comments":true,"path":"2019/04/23/顺时针打印矩阵/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/23/顺时针打印矩阵/","excerpt":"","text":"顺时针打印矩阵 题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(matrix == null)&#123; return result; &#125; int hight = matrix.length; int wide = matrix[0].length; //计算出要进行顺时钟打印的圈数 //这里为什么是取小的那个数来计算层数，这个我也说不上来，因为我只是一只小猫咪，23333。。。。 int count = (Math.min(hight,wide) -1)/2 + 1; for(int i = 0; i &lt; count; i++)&#123; //先让从左向右的值存进去； for(int k = i; k &lt; wide - i; k++)&#123; result.add(matrix[i][k]); &#125; //再存从由右上到右下的值； for(int j = i + 1; j &lt; hight - i; j++)&#123; result.add(matrix[j][wide-i-1]); &#125; //再存从右下到左下的值； //这里约束条件里hight-i-1 != i是为了不重复添加先从左到右添加的数， //如果都是那一行就没必要进行添加了 for(int k = wide - i - 2;k &gt;= i &amp;&amp; (hight-i-1 != i); k--)&#123; result.add(matrix[hight-i-1][k]); &#125; //最后存从左下到左上的值。 //这里约束条件里wide-i-1 != i是为了不重复添加先从左上到左下添加的数， //如果都是那一列就没必要进行添加了 for(int j = hight - i - 2;(j &gt; i) &amp;&amp; (wide-i-1 != i); j--)&#123; result.add(matrix[j][i]); &#125; &#125; return result; &#125;&#125; 对不起我没憋住：今天群里有位老哥的狗，会自己跑到洗手间便便，从不乱拉，这让我感觉很有意思。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 二叉树的镜像","slug":"二叉树的镜像","date":"2019-04-22T13:10:40.218Z","updated":"2019-04-22T13:10:32.620Z","comments":true,"path":"2019/04/22/二叉树的镜像/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/22/二叉树的镜像/","excerpt":"","text":"二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; TreeNode tmp = null; //当树不为空的时候我们将左子树和右子树交换 if(root != null)&#123; tmp = root.left; root.left = root.right; root.right = tmp; //当左子树不为空的时候，继续进行递归 if(root.left != null)&#123; Mirror(root.left); &#125; //当右子树不为空的时候，继续进行递归 if(root.right != null)&#123; Mirror(root.right); &#125; &#125; &#125;&#125; 水水更健康：今天听说B站的源码被上传到github上了，本人在此声明：从未clone，下载或者以任何途径获得bilibili公司的任何非正常途径公开的代码。也没有参与，传播，任何bilibili的负面信息，且不认识看源码的兄弟。特此声明！划清界限","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"剑指offer 树的子结构","slug":"树的子结构","date":"2019-04-21T14:05:37.421Z","updated":"2019-04-21T14:05:37.591Z","comments":true,"path":"2019/04/21/树的子结构/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/21/树的子结构/","excerpt":"","text":"树的子结构 ###题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; //只有当两棵树都不为空才进行比较，否则返回false if(root1 != null &amp;&amp; root2 != null)&#123; //如果当前节点值相等，我们则继续进行从当前节点的比较 if(root1.val == root2.val)&#123; result = isHaveRootB(root1,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是左子树的子树 if(!result)&#123; result = HasSubtree(root1.left,root2); &#125; //如果当前节点不相等，我们继续比较root2是不是右子树的子树 if(!result)&#123; result = HasSubtree(root1.right,root2); &#125; &#125; return result; &#125; public static boolean isHaveRootB(TreeNode node1,TreeNode node2)&#123; //如果子树已经遍历到最后，则前面都相等，此时说明是子树，返回true if(node2 == null)&#123; return true; &#125; //如果node1已经遍历完，说明没找到，此时返回false if(node1 == null)&#123; return false; &#125; //如果两个值不相等，说明不是的，直接返回false if(node1.val != node2.val)&#123; return false; &#125; //如果当前节点的值相等，则我们继续比较他们的左子树和右子树是不是相等 return isHaveRootB(node1.left,node2.left) &amp;&amp; isHaveRootB(node1.right,node2.right); &#125;&#125; 修炼：每一次做题都不会辜负自己。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hicksalmon.gitee.io/categories/刷题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://hicksalmon.gitee.io/tags/剑指offer/"}]},{"title":"程序员修炼之路","slug":"程序员修炼之路","date":"2019-04-20T03:58:27.864Z","updated":"2019-04-20T03:58:28.015Z","comments":true,"path":"2019/04/20/程序员修炼之路/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/20/程序员修炼之路/","excerpt":"","text":"程序员修炼之路 https://github.com/Snailclimb/programmer-advancement 修炼：和优秀的人一起久了，也会变得优秀。","categories":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://hicksalmon.gitee.io/tags/资源/"}]},{"title":"计划清单","slug":"缘起","date":"2019-04-17T00:40:29.763Z","updated":"2019-04-20T13:40:04.298Z","comments":true,"path":"2019/04/17/缘起/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/17/缘起/","excerpt":"","text":"缘起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.一个人去泰山看一次日出；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.坚持早睡早起多运动；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.找到一份工作；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.刷150道题（leetcode 或者其他优先刷完剑指offer）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.看两本好书。 人生：只有平淡才能让自己的人生走的更远，只有多去看世界才能有与众不同的眼界。","categories":[{"name":"计划","slug":"计划","permalink":"https://hicksalmon.gitee.io/categories/计划/"}],"tags":[{"name":"清单","slug":"清单","permalink":"https://hicksalmon.gitee.io/tags/清单/"}]},{"title":"梦","slug":"梦？","date":"2019-04-16T02:56:06.319Z","updated":"2019-04-16T04:44:15.077Z","comments":true,"path":"2019/04/16/梦？/","link":"","permalink":"https://hicksalmon.gitee.io/2019/04/16/梦？/","excerpt":"","text":"昨日 一梦惊醒睡中人，我是真睡是假睡？","categories":[{"name":"心情","slug":"心情","permalink":"https://hicksalmon.gitee.io/categories/心情/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://hicksalmon.gitee.io/tags/随记/"}]}]}